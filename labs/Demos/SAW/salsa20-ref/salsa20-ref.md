# Low-Level Specification and Refinement

Galois's implementation of Salsa20 was written mostly to test and
demonstrate SAW features. Let's try to apply these techniques to a
corresponding reference implementation written by the author of the
original written spec, Dr. Daniel J. Bernstein. The spec, supporting
documentation, and several implementations are freely available on the
author's [website](https://cr.yp.to/snuffle.html).


## Building and Analyzing the Reference Implementation

Let's examine `ref`, "a reference implementation that fits into the
eSTREAM performance-testing framework". (
[eSTREAM](https://www.ecrypt.eu.org/stream/) is a research project for
stream ciphers organized by [ECRYPT](https://www.ecrypt.eu.org/), a
collaborative research network backed by the European Union.)

```
cryptol-course$ cd labs/Demos/SAW/salsa20-ref
salsa20-ref$ mkdir build
salsa20-ref$ clang -c -g -emit-llvm -o build/salsa20-ref.bc src/salsa20.c
salsa20-ref$ opt -dot-callgraph -o /dev/null build/salsa20-ref.bc
Writing 'build/salsa20-ref.bc.callgraph.dot'...
$ dot -Tpng -o build/salsa20-ref.bc.png build/salsa20-ref.bc.callgraph.dot
```

<a href="../../../../misc/salsa20-ref.bc.png">
    <img class="center" src="../../../../misc/salsa20-ref.bc.png" alt="salsa20-ref.bc call graph">
</a>

In this callgraph, we see...numerous `ECRYPT` functions (which we can
surmise "fit...the eSTREAM...framework", some isolated `setup`
functions, and very few functions overall, none of which are called
`doubleround`, `Salsa20_expansion`, etc. We'll have to inspect the
source to understand how the reference implementation relates to our
Cryptol spec (and the written spec). At least it's short and simple...

Given the source and callgraph, we can outline a SAW script to verify
the LLVM bitcode. We will need to define function specifications, use
results as overrides reflecting the callgraph, and use uninterpreted
functions reflecting our Cryptol specification. That's the plan,
anyway...

**EXERCISE**: Create and test the following SAW script.

```SAW
// proof/salsa20-ref.saw

// qualified import of Salsa20 from `cryptol-specs`
import "../spec/Salsa20.cry" as Salsa20;

// based on "helpers.saw" from _Program Verification with SAW_:
// https://saw.galois.com/intro/
include "helpers.saw";

// TODO: Define remaining function specifications

/**
 * verification script for `salsa20/ref` bitcode
 * 
 * Encapsulating verification results into a `TopLevel` monad allows us
 * to include this in other SAW scripts with fewer side effects.
 */
let main : TopLevel () = do {
    m <- llvm_load_module "../build/salsa20-ref.bc";
	
    // salsa20_wordtobyte_result <- verify m "salsa20_wordtobyte" [] salsa20_wordtobyte_setup;
    // ECRYPT_init_result <- verify m "ECRYPT_init" [] ECRYPT_init_setup;
    // ECRYPT_keysetup_result <- verify m "ECRYPT_keysetup" [] ECRYPT_keysetup_setup;
    // ECRYPT_ivsetup_result <- verify m "ECRYPT_ivsetup" [] ECRYPT_ivsetup_setup;
    // ECRYPT_encrypt_bytes_result <- unint_verify m "ECRYPT_encrypt_bytes" [ salsa20_wordtobyte_result ] ECRYPT_encrypt_bytes_setup [...];
    // ECRYPT_decrypt_bytes_result <- unint_verify m "ECRYPT_decrypt_bytes" [ ECRYPT_encrypt_bytes_result ] ECRYPT_decrypt_bytes_setup [...];
    // ECRYPT_keystream_bytes_result <- unint_verify m "ECRYPT_keystream_bytes" [ ECRYPT_encrypt_bytes_result ] ECRYPT_keystream_bytes_setup [...];
    
    print "TODO: Verify `build/salsa20-ref.bc`...";
};
```

```
$ saw proof/salsa20-ref.saw
[12:34:56.789] Loading file ".../cryptol-course/labs/Demos/SAW/salsa20-ref/proof/salsa20-ref.saw"

[12:34:56.789] TODO: Verify `../build/salsa20-ref.bc`...
[12:34:56.789] Done!
```


### Preprocessor Directives

Let's examine `src/salsa20.c` and start specifying functions...

```C
#include "ecrypt-sync.h"
```

A header file specifying an eSTREAM interface for "synchronous stream
ciphers without authentication mechanism". Probably matters later...

```C
#define ROTATE(v,c) (ROTL32(v,c))
#define XOR(v,w) ((v) ^ (w))
#define PLUS(v,w) (U32V((v) + (w)))
#define PLUSONE(v) (PLUS((v),1))
```

Macros enable developers to consistently repeat simple statements
without overhead from function calls. This improves perfomance but does
not yield a symbol for Clang/LLVM, and thus SAW, to reference. In other
words, we cannot straightforwardly decompose a function down into its
macro invocations.

Symbols `ROTL32` and `U32V` must be defined in `ecrypt-portable.h` or a
dependency:

```
$ grep *.h -n -e "#define ROTL32"
ecrypt-machine.h:25:#define ROTL32(v, n) _lrotl(v, n)
ecrypt-portable.h:87:#define ROTL32(v, n) \
$ cat ecrypt-machine.h | head -n 25
/* ecrypt-machine.h */

/*
 * This file is included by 'ecrypt-portable.h'. It allows to override
 * the default macros for specific platforms. Please carefully check
 * the machine code generated by your compiler (with optimisations
 * turned on) before deciding to edit this file.
 */

/* ------------------------------------------------------------------------- */

#if (defined(ECRYPT_DEFAULT_ROT) && !defined(ECRYPT_MACHINE_ROT))

#define ECRYPT_MACHINE_ROT

#if (defined(WIN32) && defined(_MSC_VER))

#undef ROTL32
...
#define ROTL32(v, n) _lrotl(v, n)
$ cat ecrypt-portable.h | head -n 89
/* ecrypt-portable.h */
...
/*
 * *** Please do not edit this file. ***
 *
 * The default macros can be overridden for specific architectures by
 * editing 'ecrypt-machine.h'.
 */

#ifndef ECRYPT_PORTABLE
#define ECRYPT_PORTABLE

#include "ecrypt-config.h"

/* ------------------------------------------------------------------------- */

/*
 * The following types are defined (if available):
 *
 * u8:  unsigned integer type, at least 8 bits
 * u16: unsigned integer type, at least 16 bits
 * u32: unsigned integer type, at least 32 bits
 * u64: unsigned integer type, at least 64 bits
 *
 * s8, s16, s32, s64 -> signed counterparts of u8, u16, u32, u64
 *
 * The selection of minimum-width integer types is taken care of by
 * 'ecrypt-config.h'. Note: to enable 64-bit types on 32-bit
 * compilers, it might be necessary to switch from ISO C90 mode to ISO
 * C99 mode (e.g., gcc -std=c99).
 */
...
typedef unsigned I32T u32;
...
/*
 * The following macros are used to obtain exact-width results.
 */
...
#define U32V(v) ((u32)(v) & U32C(0xFFFFFFFF))
...
/*
 * The following macros return words with their bits rotated over n
 * positions to the left/right.
 */

#define ECRYPT_DEFAULT_ROT
...
#define ROTL32(v, n) \
  (U32V((v) << (n)) | ((v) >> (32 - (n))))
$ grep *.h -n -e "#define U32C"
$ cat ecrypt-config.h | head -n 241
/* ecrypt-config.h */

/* *** Normally, it should not be necessary to edit this file. *** */

#ifndef ECRYPT_CONFIG
#define ECRYPT_CONFIG
...
/* ------------------------------------------------------------------------- */

/*
 * Find minimal-width types to store 8-bit, 16-bit, 32-bit, and 64-bit
 * integers.
 *
 * Note: to enable 64-bit types on 32-bit compilers, it might be
 * necessary to switch from ISO C90 mode to ISO C99 mode (e.g., gcc
 * -std=c99).
 */

#include <limits.h>

/* --- check char --- */
...
#if (UCHAR_MAX / 0xFFFFU > 0xFFFFU)
...
#define U32C(v) (v##U)
#endif
...
/* --- check short --- */
...
#if (USHRT_MAX / 0xFFFFU > 0xFFFFU)
...
#define U32C(v) (v##U)
#endif
...
/* --- check int --- */
...
#if (UINT_MAX / 0xFFFFU > 0xFFFFU)
...
#define U32C(v) (v##U)
#endif
/* --- check long --- */
...
#if (ULONG_MAX / 0xFFFFUL > 0xFFFFUL)
...
#define U32C(v) (v##UL)
#endif
/* --- check long long --- */
...
#if (ULLONG_MAX / 0xFFFFULL > 0xFFFFULL)
...
#define U32C(v) (v##ULL)
#endif
```

OK, we might need these later. For now, we'll proceed until we see the
first function to specify...


### `salsa20_wordtobyte` (Reference Implementation)

```C
// (src/salsa20.c:14-56)
static void salsa20_wordtobyte(u8 output[64],const u32 input[16])
{
  u32 x[16];
  int i;

  for (i = 0;i < 16;++i) x[i] = input[i];
  for (i = 20;i > 0;i -= 2) {
    x[ 4] = XOR(x[ 4],ROTATE(PLUS(x[ 0],x[12]), 7));
    // ...
    x[15] = XOR(x[15],ROTATE(PLUS(x[14],x[13]),18));
  }
  for (i = 0;i < 16;++i) x[i] = PLUS(x[i],input[i]);
  for (i = 0;i < 16;++i) U32TO8_LITTLE(output + 4 * i,x[i]);
}
```

There is no reference to `wordtobyte` in the Cryptol or written specs.
At first glance, it might not be clear how this function relates to our
Cryptol spec (or the original written one). However, we get a strong
clue in that the second for-loop iterates 20 times writing to `x`, and
the next loop adds the original input to `x`.

**EXERCISE**: Try to find a function in `spec/Salsa20.cry` with similar
behavior, iterating a squence some number of times and then adding it
to something else.

If you came up with the `Salsa20` function, congratulations! Annotating
the source, we can see roughly the same structure:

```Cryptol
Salsa20 : [64][8] -> [64][8]
Salsa20 xs = join ar
  where
    ar = [ littleendian_inverse words | words <- xw + zs@10 ]
    xw = [ littleendian xi | xi <- split xs ]
    zs = [xw] # [ doubleround zi | zi <- zs ]
```

```C
static void salsa20_wordtobyte(u8 output[64] /* join ar */,const u32 input[16] /* xs */)
{
  u32 x[16];
  int i;

  for (i = 0;i < 16;++i) x[i] = input[i];  // xw
  for (i = 20;i > 0;i -= 2) {
    x[ 4] = XOR(x[ 4],ROTATE(PLUS(x[ 0],x[12]), 7));
    // ...
    x[15] = XOR(x[15],ROTATE(PLUS(x[14],x[13]),18));
  } // zs @ 10
  for (i = 0;i < 16;++i) x[i] = PLUS(x[i],input[i]);  // ar
  for (i = 0;i < 16;++i) U32TO8_LITTLE(output + 4 * i,x[i]);  // rejiggering
}
```

Let's get a closer look at that `U32TO8_LITTLE` macro...

```
salsa20-ref$ grep src/*.h -n -e "#define U32TO8_LITTLE"
src/ecrypt-portable.h:170:#define U32TO8_LITTLE(p, v) (((u32*)(p))[0] = U32TO32_LITTLE(v))
src/ecrypt-portable.h:235:#define U32TO8_LITTLE(p, v) \
```

```C
// (from crypt-portable.h)

#if (!defined(ECRYPT_UNKNOWN) && defined(ECRYPT_I8T_IS_BYTE))
#define U32TO8_LITTLE(p, v) (((u32*)(p))[0] = U32TO32_LITTLE(v))
#else
#define U32TO8_LITTLE(p, v) \
  do { \
    (p)[0] = U8V((v)      ); \
    (p)[1] = U8V((v) >>  8); \
    (p)[2] = U8V((v) >> 16); \
    (p)[3] = U8V((v) >> 24); \
  } while (0)
#endif
...
```

**EXERCISE**: Look familiar? What function from our Salsa20 spec does
this implement?

That's right, `littleendian_inverse`! Further analysis of the source
shows that `U32TO32_LITTLE` has different implementations reflecting
the target's endianness (directly copying on little-endian and swapping
bytes on big-endian systems), but each of these should have the same
behavior. 


## Multi-Target Testing

However, now that endianness is on our radar, we should generate big-
and little-endian bitcode to test portability of our specifications and
the bitcode. With any luck, the bitcode will be portable and we won't
have to account for endianness in our specifications...

**EXERCISE**: Generate big- and little-endian bitcode by using
`clang`'s `-target` option:

```
$ for t in $(echo "mips64 mips64le"); do clang -c -g -emit-llvm -o build/salsa20-ref-$t.bc; done
```

**EXERCISE**: Refactor the SAW script to verify each of these modules.
Rename the `main` method to `verify_salsa20_ref` and add a
`(bc : String)` parameter to pass to `llvm_load_module`. Add a new main
method that loops through each of the generated bitcode paths. Test
that the refactored script loads each of the bitcode modules:

```SAW
let verify_salsa20_ref (bc : String) : TopLevel () = do {
    m <- llvm_load_module bc;
    // ...
    print (str_concat (str_concat "TODO: Verify `" bc) "`...");
};

let main : TopLevel () = do {
    for [ "../build/salsa20-ref-mips64.bc"
        , "../build/salsa20-ref-mips64le.bc" ] verify_salsa20_ref;
    print "Done!";
};
```

```
$ saw proof/salsa20-ref.saw
[12:34:56.789] Loading file ".../cryptol-course/labs/Demos/SAW/salsa20-ref/proof/salsa20-ref.saw"

[12:34:56.789] TODO: Verify `../build/salsa20-ref-mips64.bc`...
[12:34:56.789] TODO: Verify `../build/salsa20-ref-mips64le.bc`...
[12:34:56.789] Done!
```

**EXERCISE**: Is Galois's `salsa20.c` implementation portable w.r.t.
endianness? Compile it with `-target` `mips64` and `mips64le` and see
if its verification script still succeeds.

A small win for encapsulation! Let's return to the verification effort.

**EXERCISE**: Feel free to try specifing `salsa20_wordtobyte_setup` at
this point. Or not; it's a free country...

Because this will be relatively difficult and we're about to be very
disappointed, let's just hammer this out:

```SAW

```SAW
let salsa20_wordtobyte_setup : LLVMSetup () = do {
    p_output <- alloc (array 64 i8);
    (input, p_input) <- pointer_to_fresh_readonly (array 16 i32) "input";

    execute [p_output, p_input];

    points_to p_output (from_cryptol {{ Salsa20::Salsa20 (join [Salsa20::littleendian_inverse x | x <- input]) }});
};
```

TODO: ...
