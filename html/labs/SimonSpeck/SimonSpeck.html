<?xml version='1.0' encoding='UTF-8'?> <link href="/github-markdown-css/github-css.css" rel="stylesheet"/> <meta charset="utf-8" content="text/html"/> <div class="gist"> <style class="formula-style"> svg.gh-md-to-html-formula { fill: black; } </style> <div class="gist-file"> <!-- This is the class that is responsible for the boxing! --> <div class="gist-data"> <div class="js-gist-file-update-container js-task-list-container file-box"> <div class="file" id="article-SimonSpeck"> <div class="Box-body readme blob js-code-block-container p-5 p-xl-6" id="file-docker-image-pull-md-readme" style="margin-left: 40px; margin-right: 40px; margin-top: 20px; margin-bottom: 20px"> <article class="markdown-body entry-content container-lg" itemprop="text"> <h1> <a aria-hidden="true" class="anchor" href="#introduction" id="user-content-introduction"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introduction</h1> <h2> <a aria-hidden="true" class="anchor" href="#prerequisites" id="user-content-prerequisites"><span aria-hidden="true" class="octicon octicon-link"></span></a>Prerequisites</h2> <p>Before working through this lab, you'll need</p> <ul> <li>Cryptol to be installed,</li> <li>this module to load successfully, and</li> <li>an editor for completing the exercises in associated files.</li> </ul> <p>You'll also need experience with</p> <ul> <li>loading modules and evaluating functions in the interpreter,</li> <li>the <code>:prove</code> command,</li> <li>manipulating sequences using <code>#</code>, <code>take</code>, <code>split</code>, <code>join</code>, <code>last</code>, <code>scanl</code>, and <code>transpose</code>,</li> <li>writing functions and properties,</li> <li>sequence comprehensions,</li> <li>functions with curried parameters, and</li> <li>logical, comparison, and arithmetic operators.</li> </ul> <h2> <a aria-hidden="true" class="anchor" href="#skills-youll-learn" id="user-content-skills-youll-learn"><span aria-hidden="true" class="octicon octicon-link"></span></a>Skills You'll Learn</h2> <p>By the end of this lab you will have gained experience with defining and using Cryptol's parameterized modules to make basic families of cryptographic routines.</p> <h2> <a aria-hidden="true" class="anchor" href="#load-this-module" id="user-content-load-this-module"><span aria-hidden="true" class="octicon octicon-link"></span></a>Load This Module</h2> <p>This lab is a <a href="https://en.wikipedia.org/wiki/Literate_programming" rel="nofollow">literate</a> Cryptol document --- that is, it can be loaded directly into the Cryptol interpreter. Load this module from within the Cryptol interpreter running in the <code>cryptol-course</code> directory with:</p> <pre lang="Xcryptol"><code>Loading module Cryptol Cryptol&gt; :m labs::SimonSpeck::SimonSpeck Loading module Cryptol Loading module labs::SimonSpeck::Simon::Simon Loading module labs::SimonSpeck::Simon::simon_32_64 Loading module labs::SimonSpeck::SimonSpeck </code></pre> <p>We start by defining a new module for this lab:</p> <pre lang="cryptol"><code>module labs::SimonSpeck::SimonSpeck where </code></pre> <p>You do not need to enter the above into the interpreter; the previous <code>:m ...</code> command loaded this literate Cryptol file automatically.<br/> In general, you should run <code>Xcryptol session</code> commands in the interpreter and leave <code>cryptol</code> code alone to be parsed by <code>:m ...</code>.</p> <h1> <a aria-hidden="true" class="anchor" href="#learning-to-use-parameterized-modules-with-simon-and-speck" id="user-content-learning-to-use-parameterized-modules-with-simon-and-speck"><span aria-hidden="true" class="octicon octicon-link"></span></a>Learning to use Parameterized Modules with Simon and Speck</h1> <p>This lab will introduce the student to the use of Cryptol's <strong>Parameterized Modules</strong> through the <a href="https://en.wikipedia.org/wiki/Simon_(cipher)" rel="nofollow">Simon</a> and <a href="https://en.wikipedia.org/wiki/Speck_(cipher)" rel="nofollow">Speck</a> algorithms.</p> <p>Parameterized Modules allow a user to create a family of modules which differ by the selection of type parameters that are defined for a base module.</p> <p>We will introduce parameterized modules through an implementation of the <code>Simon</code> algorithm. The student will then be asked to imitate this pattern and implement the <code>Speck</code> algorithm.</p> <p>Note that we have made use of modules throughout the course. In fact each lab was defined in its own Cryptol module. But because this lab introduces further concepts around the definition and use of modules, this lab will not be entirely self-contained in this file.</p> <h1> <a aria-hidden="true" class="anchor" href="#introducing-parameterized-modules" id="user-content-introducing-parameterized-modules"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introducing Parameterized Modules</h1> <p>A <strong>parameterized module</strong> is a module which has a collection of type parameters that can be be used as implicit type variables for all of the definitions it contains. New modules can specify concrete values for these type parameters and easily create a variety of new functionality which reutilizes the functionality in the base parameterized module.</p> <p>This feature is especially useful for cryptographic applications which often define many variants of a cryptographic routine relying on common functionality. Parameterized modules help specification writers avoid writing redundant code and can help strengthen the confidence in the core of a verified stack of cryptographic primitives.</p> <p>This template describes how to define a generic parameterized module:</p> <pre lang="example"><code>module MyParameterizedModule where parameter /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var value parameter of built-in type github-markdown-css/ html/ labs/ misc/ scripts/ specs/ param_builtin : [16][8] /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var numeric type parameter; must be a finite whole number github-markdown-css/ html/ labs/ misc/ scripts/ specs/ type param_NumType : # type constraint (fin param_NumType, param_NumType &gt;= 1) /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var arbitrary type parameter; must be comparable and logical github-markdown-css/ html/ labs/ misc/ scripts/ specs/ type param_AnyType : INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs type constraint (Cmp param_AnyType, Logic param_AnyType) /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var value parameter of parameter type github-markdown-css/ html/ labs/ misc/ scripts/ specs/ param_val: param_AnyType /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var a type defined outside parameter scope github-markdown-css/ html/ labs/ misc/ scripts/ specs/ type OtherType = [param_NumType]param_AnyType /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var value parameter defined outside parameter scope github-markdown-css/ html/ labs/ misc/ scripts/ specs/ value_userdef : SomeOtherType // ...other definitions in public scope; may use parameters defined above... private /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var private value of parameter type github-markdown-css/ html/ labs/ misc/ scripts/ specs/ value_priv_val : param_AnyType </code></pre> <p>Type parameters <code>param_builtin</code>, <code>param_NumType</code>, <em>etc...</em> which appear indented under the <code>parameter</code> keyword declare types which can be used throughout the module.</p> <p>We also introduce the <code>private</code> keyword here which allows the user to define functions and values which are only visible from within the module -- other modules importing this one will not be able to directly access these definitions.</p> <p>New modules can import this module and specify concrete values for these parameters as follows:</p> <pre lang="example"><code>module MyConcreteModule = MyParameterizedModule where param_builtin = [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f] type param_NumType = 42 type param_AnyType = Bit param_val = True </code></pre> <p>Users can then import <code>MyConcreteModule</code> which will contain all of the functionality in <code>MyParameterizedModule</code> where the functionality is specialized to the concrete values.</p> <h1> <a aria-hidden="true" class="anchor" href="#writing-a-parameterized-module-for-simon" id="user-content-writing-a-parameterized-module-for-simon"><span aria-hidden="true" class="octicon octicon-link"></span></a>Writing a Parameterized Module for Simon</h1> <p>Let's take a look at writing a parameterized module for Simon. We will be using <a href="https://eprint.iacr.org/2013/404" rel="nofollow">"The Simon and Speck Families of Lightweight Block Ciphers"</a> as our reference for building this formal specification.</p> <p>Look at page 10 of this document. We see that the specification defines a family of related block ciphers for <code>Simon</code> depending on the following parameters:</p> <ul> <li> <code>word size n</code> -- The basic register size in bits</li> <li> <code>key words m</code> -- The number of words in a key</li> <li> <code>const seq</code> -- A bit sequence</li> <li> <code>rounds T</code> -- The number of rounds in the key schedule</li> </ul> <p>Furthermore, the different versions of <code>Simon</code> are named after the <code>block size</code> and the <code>key size</code> they use and these two values are functions of the <code>word size n</code> and <code>key words m</code>:</p> <ul> <li> <code>block size 2*n</code> -- The size of the block in bits</li> <li> <code>key size m*n</code> -- The size of the key in bits</li> </ul> <p>In this lab we have defined a parameterized base module and a family of derived modules in <code>[CRYPTOLCOURSE]/labs/SimonSpeck/Simon/</code>. The base module is called <code>Simon.cry</code> and the derived modules are named <code>simon_[bs]_[ks].cry</code> where <code>[ks]</code> and <code>[bs]</code> vary over the valid block and key sized.</p> <p>Here is the header for the <code>Simon.cry</code> base module:</p> <pre lang="example"><code>module labs::SimonSpeck::Simon::Simon where module labs::SimonSpeck::Simon::Simon where parameter /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var word size github-markdown-css/ html/ labs/ misc/ scripts/ specs/ type n : # type constraint (16 &lt;= n, n &lt;= 64) /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var number of words in key github-markdown-css/ html/ labs/ misc/ scripts/ specs/ type m : # type constraint (2 &lt;= m, m &lt;= 4) /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var number of rounds in key schedule github-markdown-css/ html/ labs/ misc/ scripts/ specs/ type T : # type constraint (32 &lt;= T, T &lt;= 72) /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var index of z-sequence used (i.e. use sequence z_j) github-markdown-css/ html/ labs/ misc/ scripts/ specs/ type j : # type constraint (0 &lt;= j, j &lt;= 4) type blockSize = 2 INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs n type keySize = m INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs n // Other definitions omitted, see // // [CRYPTOLCOURSE]/labs/SimonSpeck/Simon/Simon.cry // // for the remainder of the Simon specification. </code></pre> <p>Note that four module parameters are declared (<code>n</code>, <code>m</code>, <code>T</code>, and <code>j</code>) which reflect the four from page 10 of the specification document. We are also able to declare <code>blockSize</code> and <code>keySize</code> types using these variables that match the definitions in the specification.</p> <p><code>Simon</code> defines five different bit sequences <code>z0, ..., z4</code>. Note that we introduce the parameter <code>j</code> to indicate the which of these sequences we will use.</p> <p>We are also able to specify general type constraints for these parameters. The line that begins <code>type constraint</code> places some general bounds on the ranges of values that are possible for each parameter.</p> <p>We can create a concrete module by specifying values for the module type parameters as follows:</p> <pre lang="example"><code>module labs::SimonSpeck::Simon::simon_32_64 = labs::SimonSpeck::Simon::Simon where type n = 16 type m = 4 type T = 32 type j = 0 </code></pre> <p>This code appears in the file <code>[CRYPTOLCOURSE]/labs/SimonSpeck/Simon/simon_32_64.cry</code> and defines a new module <code>labs::SimonSpeck::Simon::simon_32_64</code> with concrete values for the <code>simon32/64</code> block cipher according to the specification. The user can import this module and use the concretized <code>encrypt</code> function as follows:</p> <pre><code>import labs::SimonSpeck::Simon::simon_32_64 as simon_32_64 test_K = join [0x1918, 0x1110, 0x0908, 0x0100] test_P = join [0x6565, 0x6877] test_C = join [0xc69b, 0xe9bb] property test_32_64 = simon_32_64::encrypt test_K test_P == test_C </code></pre> <p>You can check that this test vector passes by running <code>:check test_32_64</code>.</p> <h2> <a aria-hidden="true" class="anchor" href="#simon-details" id="user-content-simon-details"><span aria-hidden="true" class="octicon octicon-link"></span></a>Simon Details</h2> <p>We will not walk through the entire implementation of Simon; however, we will describe some of the definitions and interesting features found in the specification.</p> <p>Additional documentation can be found in the Simon source file <code>[CRYPTOLCOURSE]/labs/SimonSpeck/Simon/Simon.cry</code> which you are encouraged to review as part of this lab.</p> <p><strong>Bit Sequences</strong> <code>Simon</code> defines five different bit sequences and each <code>Simon</code> variant selects one of these to use in its definition. We could have defined a value parameter which could have been specified in each of the concrete <code>Simon</code> modules; however, the bit sequences are reused between these variants.</p> <p>To avoid having to rewrite the bit sequences we define all five in the base parameterized module as follows:</p> <pre lang="example"><code> // We define the sequences u, v, w, and z_j following the paper u = join (repeat`{inf} 0b1111101000100101011000011100110) v = join (repeat`{inf} 0b1000111011111001001100001011010) w = join (repeat`{inf} 0b1000010010110011111000110111010) z0 = u z1 = v z2 = join [ dibit ^ 0b01 | dibit &lt;- groupBy`{2} u ] z3 = join [ dibit ^ 0b01 | dibit &lt;- groupBy`{2} v ] z4 = join [ dibit ^ 0b01 | dibit &lt;- groupBy`{2} w ] // Z will be the sequence selected by the module parameter j Z = [z0, z1, z2, z3, z4]@(`j:[width j]) </code></pre> <p>The module parameter <code>j</code> is then used to index into the array of these bit sequences <code>[z0, z1, z2, z3, z4]</code> to select a specific sequence for each variant. The variable <code>Z</code> then refers to the selected sequence and is used in the definition of the round function.</p> <p><strong>Key Expansion</strong></p> <p>There are two interesting features of the <code>KeyExpansion</code> function in this implementation which lead, ultimately, to conditionally defined behavior when the number of <code>Simon</code> key words <code>m</code> is equal to <code>4</code>.</p> <p>Here is the code that we will be discussing:</p> <pre lang="example"><code> /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs "tmp" appears as the name of a variable in the Simon key INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs expansion sample implementation on page 13. The tmp function INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs below captures the possible final values the expression has, INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs taking into account the type parameter `m` containing the INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs number of key words. github-markdown-css/ html/ labs/ misc/ scripts/ specs/ tmp: [n] -&gt; [n] -&gt; [n] tmp k1 k2 = r where r = t ^ (t &gt;&gt;&gt; 1) t = if `m == 0x4 then (t' ^ k2) else t' t' = (k1 &gt;&gt;&gt; 3) /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs The Simon Key Expansion function. github-markdown-css/ html/ labs/ misc/ scripts/ specs/ KeyExpansion : [keySize] -&gt; [T][n] KeyExpansion K = take Ks where Kis : [m][n] Kis = reverse(split K) Ks : [inf][n] Ks = Kis # [ ~k0 ^ (tmp k1 k2) ^ (zext [z]) ^ (zext 0x3) | k0 &lt;- Ks | k1 &lt;- drop`{m-1} Ks | k2 &lt;- drop`{max m 3 - 3} Ks // gadget to typecheck "drop`{m-3}" | z &lt;- Z ] </code></pre> <p>First, the <code>tmp</code> function is named to mirror the sample implementation found in the specification on page 13. <code>KeyExpansion</code> xors in earlier values of the key expansion conditionally on whether there are four key words (<code>m == 4</code>) for this variant.</p> <p>Note that when <code>m != 4</code> the second parameter <code>k2</code> is ignored by the conditional statement defining <code>t</code>.</p> <p>Second, in the parallel enumeration found in <code>KeyExpansion</code> we see that <code>k2</code> is drawn from the sequence <code>drop`{max m 3 - 3}</code>. The <code>max m 3</code> expression guarantees that after subtracting <code>3</code> the result is non-negative. Note that the value <code>k2</code> is ignored in the <code>tmp</code> function when <code>m != 4</code> and that <code>max m 3 - 3</code> is equivalent to <code>m - 3</code> when <code>m == 4</code>.</p> <p>Without the <code>max m 3</code> expression, Cryptol's type checker will detect that the <code>m - 3</code> could potentially be negative and suggest that an additional constraint <code>m &gt;= 3</code> should be added. However, we want to allow <code>m</code> to take on the values <code>2</code> or <code>3</code> as well, hence add this as a workaround.</p> <p>Ultimately, these choices allow us to define a single <code>KeyExpansion</code> function for all variants of <code>Simon</code>.</p> <h1> <a aria-hidden="true" class="anchor" href="#writing-a-parameterized-module-for-speck" id="user-content-writing-a-parameterized-module-for-speck"><span aria-hidden="true" class="octicon octicon-link"></span></a>Writing a Parameterized Module for Speck</h1> <p>Now it's your turn to try writing a parameterized module. You will also get more practice reading and writing a cryptographic specification.</p> <p><strong>EXERCISE</strong>: Write a parameterized module for <code>Speck</code>. Refer to Section 4 from reference [1]. The corresponding <code>Speck</code> Cryptol files should be written in the <code>Speck</code> folder provided in this lab directory. Consider using the <code>Simon</code> implementation as a reference -- many of the patterns you will encounter writing up <code>Speck</code> will mirror <code>Simon</code>.</p> <p>If you name your files as suggested in the <a href="/labs/SimonSpeck/Speck/README.html">Speck README.md</a> file, then you should be able to load the <code>SpeckTestVectors</code> module also located in the <code>Speck</code> folder as follows and verify that you have correctly implemented the functions:</p> <pre lang="Xcryptol"><code>Loading module Cryptol Cryptol&gt; :m labs::SimonSpeck::Speck::SpeckTestVectors labs::SimonSpeck::Simon::SpeckTestVectors&gt; :prove all_speck_vectors_pass Q.E.D. (Total Elapsed Time: 0.021s, using "Z3") </code></pre> <p><strong>ADDITIONAL EXERCISE</strong>: The test vectors below only test the encryption direction for <code>Speck</code>. Define the decryption direction for the round function and algorithm and try writing properties and/or test vectors to verify that these functions are inverses. You may need to try different solvers like <code>abc</code> for some property verifications to complete in a reasonable amount of time.</p> <h1> <a aria-hidden="true" class="anchor" href="#references" id="user-content-references"><span aria-hidden="true" class="octicon octicon-link"></span></a>References</h1> <p>[1] Beaulieu R., Shors D., et. al. "The Simon and Speck Families of Lightweight Block Ciphers". eprint-2013-404.pdf. National Security Agency. June, 2013.</p> <p>[2] Beaulieu R., Shors D., et. al. "SIMON and SPECK Implementation Guide". National Security Agency. January, 2019.</p> <h1> <a aria-hidden="true" class="anchor" href="#solicitation" id="user-content-solicitation"><span aria-hidden="true" class="octicon octicon-link"></span></a>Solicitation</h1> <p>How was your experience with this labs Suggestions are welcome in the form of a ticket on the course GitHub page: <a href="https://github.com/weaversa/cryptol-course/issues">https://github.com/weaversa/cryptol-course/issues</a></p> <h1> <a aria-hidden="true" class="anchor" href="#from-here-you-can-go-somewhere" id="user-content-from-here-you-can-go-somewhere"><span aria-hidden="true" class="octicon octicon-link"></span></a>From here, you can go somewhere!</h1> <table> <thead> <tr> <th align="right"></th> <th align="center"></th> <th></th> </tr> </thead> <tbody> <tr> <td align="right"></td> <td align="center"><a href="/labs/KeyWrapping/KeyWrapping.html">- Key Wrapping</a></td> <td></td> </tr> <tr> <td align="right"></td> <td align="center"><strong>Parameterized Modules</strong></td> <td></td> </tr> </tbody> </table> </article> </div> </div> </div> </div> </div> </div>
