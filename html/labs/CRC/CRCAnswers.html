<?xml version='1.0' encoding='UTF-8'?> <link href="/github-markdown-css/github-css.css" rel="stylesheet"/> <meta charset="utf-8" content="text/html"/> <div class="gist"> <style class="formula-style"> svg.gh-md-to-html-formula { fill: black; } </style> <div class="gist-file"> <!-- This is the class that is responsible for the boxing! --> <div class="gist-data"> <div class="js-gist-file-update-container js-task-list-container file-box"> <div class="file" id="article-CRCAnswers"> <div class="Box-body readme blob js-code-block-container p-5 p-xl-6" id="file-docker-image-pull-md-readme" style="margin-left: 40px; margin-right: 40px; margin-top: 20px; margin-bottom: 20px"> <article class="markdown-body entry-content container-lg" itemprop="text"> <h1> <a aria-hidden="true" class="anchor" href="#introduction" id="user-content-introduction"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introduction</h1> <p>This lab provides a series of exercises focused on Cyclic Redundancy Checks.</p> <h2> <a aria-hidden="true" class="anchor" href="#prerequisites" id="user-content-prerequisites"><span aria-hidden="true" class="octicon octicon-link"></span></a>Prerequisites</h2> <p>Before working through this lab, you'll need</p> <ul> <li>Cryptol to be installed,</li> <li>this module to load successfully, and</li> <li>an editor for completing the exercises in this file.</li> </ul> <p>You'll also need experience with</p> <ul> <li>loading modules and evaluating functions in the interpreter,</li> <li>Cryptol's sequence types,</li> <li>the <code>:prove</code> command,</li> <li>manipulating sequences using <code>#</code>, <code>join</code>, and <code>reverse</code>,</li> <li>writing functions,</li> <li>sequence comprehensions, and</li> <li>logical, comparison, arithmetic, and conditional operators.</li> </ul> <h2> <a aria-hidden="true" class="anchor" href="#skills-youll-learn" id="user-content-skills-youll-learn"><span aria-hidden="true" class="octicon octicon-link"></span></a>Skills You'll Learn</h2> <p>By the end of this lab you will have implemented a family of 32-bit Cyclic Redundancy Checks.</p> <p>You'll also gain experience with</p> <ul> <li>Cryptol's support for polynomials including expressing polynomials and using <code>pmod</code>,</li> <li>functions with curried parameters,</li> <li>writing functions, and</li> <li>sequence comprehensions.</li> </ul> <h2> <a aria-hidden="true" class="anchor" href="#load-this-module" id="user-content-load-this-module"><span aria-hidden="true" class="octicon octicon-link"></span></a>Load This Module</h2> <p>This lab is a <a href="https://en.wikipedia.org/wiki/Literate_programming" rel="nofollow">literate</a> Cryptol document --- that is, it can be loaded directly into the Cryptol interpreter. Load this module from within the Cryptol interpreter running in the <code>cryptol-course</code> directory with:</p> <pre lang="Xcryptol"><code>Loading module Cryptol Cryptol&gt; :m labs::CRC::CRCAnswers Loading module Cryptol Loading module labs::CRC::CRCAnswers </code></pre> <p>We start by defining a new module for this lab:</p> <pre lang="cryptol"><code>module labs::CRC::CRCAnswers where </code></pre> <p>You do not need to enter the above into the interpreter; the previous <code>:m ...</code> command loaded this literate Cryptol file automatically. In general, you should run <code>Xcryptol session</code> commands in the interpreter and leave <code>cryptol</code> code alone to be parsed by <code>:m ...</code>.</p> <h1> <a aria-hidden="true" class="anchor" href="#cyclic-redundancy-checks" id="user-content-cyclic-redundancy-checks"><span aria-hidden="true" class="octicon octicon-link"></span></a>Cyclic Redundancy Checks</h1> <p>From [1],</p> <blockquote> <p>A cyclic redundancy check (CRC) is an error-detecting code commonly used in digital networks and storage devices to detect accidental changes to raw data.</p> </blockquote> <p>CRCs are important to cryptography because they are often used, in part, to protect the integrity of key material (see Section 6.1 of NIST's <a href="https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-57pt1r5.pdf" rel="nofollow">Recommendation for Key Management</a>).</p> <p>In this lab we will create Cryptol specifications for a family of different CRCs.</p> <h2> <a aria-hidden="true" class="anchor" href="#mathematics-of-crcs" id="user-content-mathematics-of-crcs"><span aria-hidden="true" class="octicon octicon-link"></span></a>Mathematics of CRCs</h2> <p>A simple mathematical definition of CRCs can be found here: <a href="https://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks#Maths" rel="nofollow">Mathematics of cyclic redundancy checks</a></p> <blockquote> <p>R(x) = M(x) INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs x<sup>n</sup> mod G(x)</p> <p>Here M(x) is the original message polynomial and G(x) is the degree-n generator polynomial. The bits of M(x) INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs x<sup>n</sup> are the original message with n zeroes added at the end. The CRC 'checksum' is formed by the coefficients of the remainder polynomial R(x) whose degree is strictly less than n.</p> </blockquote> <p>To start, our definition of CRC in Cryptol will need a generator polynomial <code>G</code> of degree <code>n</code>. Cryptol has some support for polynomials, for instance, one can express a polynomial like so <code>&lt;| x^^3 + x + 1 |&gt;</code> which is simply the four bit string <code>0b1011</code>. It's important to note that even though this is a degree three polynomial, it takes four bits to represent. Generally, Cryptol's representation of a degree <code>n</code> polynomial is a sequence of <code>n+1</code> bits where each monomial is represented by a <code>True</code> bit in the sequence. For more on polynomials in Cryptol, see Section 5.2 of <a href="https://github.com/GaloisInc/cryptol/blob/master/docs/ProgrammingCryptol.pdf">Programming Cryptol</a>.</p> <p>We'll also need a message <code>M</code> which is simply a sequence of <code>m</code> bits. Notice that the definition from [2] tells us that <code>M</code> is extended (concatenated) with <code>n</code> zeroes prior to performing the modulus operation. Cryptol supports multiplying (<code>pmult</code>), dividing (<code>pdiv</code>), and performing the modulus (<code>pmod</code>) of polynomials. This is more than we need to define a simple CRC function.</p> <p><strong>EXERCISE</strong>: Here we provide a skeleton CRC for you to fill in according to the definition above. Use the <code>CRCSimpleTest</code> property to help you get it right.</p> <pre lang="cryptol"><code>CRCSimple : {n, m} (fin n, fin m) =&gt; [n+1] -&gt; [m] -&gt; [n] CRCSimple G M = R where R = pmod M' G M' = M # (0 : [n]) </code></pre> <p>This test-case is from [1].</p> <pre lang="cryptol"><code>property CRCSimpleTest = CRCSimple G 0b11010011101100 == 0b100 where G = &lt;| x^^3 + x + 1 |&gt; </code></pre> <h2> <a aria-hidden="true" class="anchor" href="#a-family-of-crc32s" id="user-content-a-family-of-crc32s"><span aria-hidden="true" class="octicon octicon-link"></span></a>A Family of CRC32s</h2> <p>Bastian Molkenthin's <a href="http://www.sunshine2k.de/coding/javascript/crc/crc_js.html" rel="nofollow">CRC simulator</a> [3] supports nine different 32-bit CRCs.</p> <table> <thead> <tr> <th>Name</th> <th>Polynomial</th> <th>Initial Fill</th> <th>Post-XOR</th> <th>Reflect Input Bytes</th> <th>Reverse Output</th> </tr> </thead> <tbody> <tr> <td>CRC32</td> <td>0x104C11DB7</td> <td>0xFFFFFFFF</td> <td>0xFFFFFFFF</td> <td>True</td> <td>True</td> </tr> <tr> <td>CRC32_BZIP2</td> <td>0x104C11DB7</td> <td>0xFFFFFFFF</td> <td>0xFFFFFFFF</td> <td>False</td> <td>False</td> </tr> <tr> <td>CRC32_C</td> <td>0x11EDC6F41</td> <td>0xFFFFFFFF</td> <td>0xFFFFFFFF</td> <td>True</td> <td>True</td> </tr> <tr> <td>CRC32_D</td> <td>0x1A833982B</td> <td>0xFFFFFFFF</td> <td>0xFFFFFFFF</td> <td>True</td> <td>True</td> </tr> <tr> <td>CRC32_MPEG2</td> <td>0x104C11DB7</td> <td>0xFFFFFFFF</td> <td>0x00000000</td> <td>False</td> <td>False</td> </tr> <tr> <td>CRC32_POSIX</td> <td>0x104C11DB7</td> <td>0x00000000</td> <td>0xFFFFFFFF</td> <td>False</td> <td>False</td> </tr> <tr> <td>CRC32_Q</td> <td>0x1814141AB</td> <td>0x00000000</td> <td>0x00000000</td> <td>False</td> <td>False</td> </tr> <tr> <td>CRC32_JAMCRC</td> <td>0x104C11DB7</td> <td>0xFFFFFFFF</td> <td>0x00000000</td> <td>True</td> <td>True</td> </tr> <tr> <td>CRC32_XFER</td> <td>0x1000000AF</td> <td>0x00000000</td> <td>0x00000000</td> <td>False</td> <td>False</td> </tr> </tbody> </table> <p>Here we can see that the CRCs differ not only in polynomials (choice of <code>G</code>) but also in four other parameters that we'll go over soon. Though first, two of these, namely, <code>CRC32_Q</code> and <code>CRC32_XFER</code>, are simple enough to be compatible with <code>CRCSimple</code>.</p> <p>Here we define a test message using the <a href="https://en.wikipedia.org/wiki/The_quick_brown_fox_jumps_over_the_lazy_dog" rel="nofollow">canonical pangram</a>.</p> <pre lang="cryptol"><code>testM = "The quick brown fox jumps over the lazy dog" </code></pre> <pre lang="cryptol"><code>property CRCSimple_QTest = CRCSimple G (join testM) == 0xf4965ffc where G = &lt;| x^^32 + x^^31 + x^^24 + x^^22 + x^^16 + x^^14 + x^^8 + x^^7 + x^^5 + x^^3 + x + 1 |&gt; </code></pre> <pre lang="cryptol"><code>property CRCSimple_XFERTest = CRCSimple G (join testM) == 0x140493e5 where G = &lt;| x^^32 + x^^7 + x^^5 + x^^3 + x^^2 + x + 1 |&gt; </code></pre> <p><strong>EXERCISE</strong>: Make sure these two properties prove using the <code>CRCSimple</code> function you defined above.</p> <h3> <a aria-hidden="true" class="anchor" href="#fully-parameterized-crc" id="user-content-fully-parameterized-crc"><span aria-hidden="true" class="octicon octicon-link"></span></a>Fully Parameterized CRC</h3> <p>To support the full suite of CRC32's from [3], we need to add four parameters.</p> <ul> <li>Initial Fill (<code>fill</code>) <ul> <li>Refers to the initial fill of a CRC when implemented by a linear feedback shift register. Since we're implementing CRC here with polynomial arithmetic, we can add this parameter by XORing the initial fill into the high-order bits of the zero-expanded message before performing the modulus operation.</li> </ul> </li> <li>Post-XOR (<code>post</code>) <ul> <li>A sequence of bits that are XOR'd into the remainder polynomial to create the final output.</li> </ul> </li> <li>Reflect Input Bytes (<code>rib</code>) <ul> <li>Denotes whether or not the input (when viewed as a sequence of bytes) should have the bits inside each byte reversed.</li> </ul> </li> <li>Reverse Output (<code>ro</code>) <ul> <li>Denotes whether or not the output (when viewed as a bitvector) should be reversed.</li> </ul> </li> </ul> <p><strong>EXERCISE</strong>: Here we provide a skeleton for a fully parameterized CRC for you to fill in. It is essentially the <code>CRCSimple</code> function augmented with the four extra parameters given above. Use the <code>CRC32Test</code> property to help you get it right.</p> <p>Note, since there is now a parameter that possibly reflects the input bytes, to make things a little easier here, we've reshaped the input <code>M</code> as a sequence of bytes.</p> <pre lang="cryptol"><code>CRC : {n, m} (fin n, fin m) =&gt; [n+1] -&gt; [n] -&gt; [n] -&gt; Bit -&gt; Bit -&gt; [m][8] -&gt; [n] CRC G fill post rib ro M = if ro then reverse R else R where R = pmod (fill' ^ M'') G ^ post M' = join (if rib then (map reverse M) else M) M'' = M' # (0 : [n]) fill' = fill # (0 : [m*8]) </code></pre> <p>Here is a definition of CRC32, using the parameterized <code>CRC</code> function.</p> <pre lang="cryptol"><code>CRC32 = CRC G 0xffffffff 0xffffffff True True where G = &lt;| x^^32 + x^^26 + x^^23 + x^^22 + x^^16 + x^^12 + x^^11 + x^^10 + x^^8 + x^^7 + x^^5 + x^^4 + x^^2 + x + 1 |&gt; property CRC32Test = CRC32 testM == 0x414FA339 </code></pre> <p><strong>EXERCISE</strong>: Use the values in the table above to fill in values for each of the following eight 32-bit CRCs. Use the associated properties to help you get them right, or test them yourself with the <a href="http://www.sunshine2k.de/coding/javascript/crc/crc_js.html" rel="nofollow">CRC simulator</a> [3].</p> <h3> <a aria-hidden="true" class="anchor" href="#bzip2" id="user-content-bzip2"><span aria-hidden="true" class="octicon octicon-link"></span></a>BZIP2</h3> <pre lang="cryptol"><code>CRC32_BZIP2 = CRC G 0xffffffff 0xffffffff False False where G = &lt;| x^^32 + x^^26 + x^^23 + x^^22 + x^^16 + x^^12 + x^^11 + x^^10 + x^^8 + x^^7 + x^^5 + x^^4 + x^^2 + x + 1 |&gt; property CRC32_BZIP2Test = CRC32_BZIP2 testM == 0x459DEE61 </code></pre> <h3> <a aria-hidden="true" class="anchor" href="#c" id="user-content-c"><span aria-hidden="true" class="octicon octicon-link"></span></a>C</h3> <pre lang="cryptol"><code>CRC32_C = CRC G 0xffffffff 0xffffffff True True where G = &lt;| x^^32 + x^^28 + x^^27 + x^^26 + x^^25 + x^^23 + x^^22 + x^^20 + x^^19 + x^^18 + x^^14 + x^^13 + x^^11 + x^^10 + x^^9 + x^^8 + x^^6 + 1 |&gt; property CRC32_CTest = CRC32_C testM == 0x22620404 </code></pre> <h3> <a aria-hidden="true" class="anchor" href="#d" id="user-content-d"><span aria-hidden="true" class="octicon octicon-link"></span></a>D</h3> <pre lang="cryptol"><code>CRC32_D = CRC G 0xffffffff 0xffffffff True True where G = &lt;| x^^32 + x^^31 + x^^29 + x^^27 + x^^21 + x^^20 + x^^17 + x^^16 + x^^15 + x^^12 + x^^11 + x^^5 + x^^3 + x + 1 |&gt; property CRC32_DTest = CRC32_D testM == 0x9D251C62 </code></pre> <h3> <a aria-hidden="true" class="anchor" href="#mpeg2" id="user-content-mpeg2"><span aria-hidden="true" class="octicon octicon-link"></span></a>MPEG2</h3> <pre lang="cryptol"><code>CRC32_MPEG2 = CRC G 0xffffffff 0x00000000 False False where G = &lt;| x^^32 + x^^26 + x^^23 + x^^22 + x^^16 + x^^12 + x^^11 + x^^10 + x^^8 + x^^7 + x^^5 + x^^4 + x^^2 + x + 1 |&gt; property CRC32_MPEG2Test = CRC32_MPEG2 testM == 0xBA62119E </code></pre> <h3> <a aria-hidden="true" class="anchor" href="#posix" id="user-content-posix"><span aria-hidden="true" class="octicon octicon-link"></span></a>POSIX</h3> <pre lang="cryptol"><code>CRC32_POSIX = CRC G 0x00000000 0xffffffff False False where G = &lt;| x^^32 + x^^26 + x^^23 + x^^22 + x^^16 + x^^12 + x^^11 + x^^10 + x^^8 + x^^7 + x^^5 + x^^4 + x^^2 + x + 1 |&gt; property CRC32_POSIXTest = CRC32_POSIX testM == 0x36B78081 </code></pre> <h3> <a aria-hidden="true" class="anchor" href="#q" id="user-content-q"><span aria-hidden="true" class="octicon octicon-link"></span></a>Q</h3> <pre lang="cryptol"><code>CRC32_Q = CRC G 0x00000000 0x00000000 False False where G = &lt;| x^^32 + x^^31 + x^^24 + x^^22 + x^^16 + x^^14 + x^^8 + x^^7 + x^^5 + x^^3 + x + 1 |&gt; property CRC32_QTest = CRC32_Q testM == 0xF4965FFC </code></pre> <h3> <a aria-hidden="true" class="anchor" href="#jamcrc" id="user-content-jamcrc"><span aria-hidden="true" class="octicon octicon-link"></span></a>JAMCRC</h3> <pre lang="cryptol"><code>CRC32_JAMCRC = CRC G 0xffffffff 0x00000000 True True where G = &lt;| x^^32 + x^^26 + x^^23 + x^^22 + x^^16 + x^^12 + x^^11 + x^^10 + x^^8 + x^^7 + x^^5 + x^^4 + x^^2 + x + 1 |&gt; property CRC32_JAMCRCTest = CRC32_JAMCRC testM == 0xBEB05CC6 </code></pre> <h3> <a aria-hidden="true" class="anchor" href="#xfer" id="user-content-xfer"><span aria-hidden="true" class="octicon octicon-link"></span></a>XFER</h3> <pre lang="cryptol"><code>CRC32_XFER = CRC G 0x00000000 0x00000000 False False where G = &lt;| x^^32 + x^^7 + x^^5 + x^^3 + x^^2 + x + 1 |&gt; property CRC32_XFERTest = CRC32_XFER testM == 0x140493E5 </code></pre> <h2> <a aria-hidden="true" class="anchor" href="#parting-exercises" id="user-content-parting-exercises"><span aria-hidden="true" class="octicon octicon-link"></span></a>Parting Exercises</h2> <p>This lab defined the 32-bit CRCs from [3]. You might also consider defining the 8, 16, and 64-bit CRC's from [3] or any of the CRCs given in [1], Section "Polynomial representations of cyclic redundancy checks".</p> <h1> <a aria-hidden="true" class="anchor" href="#references" id="user-content-references"><span aria-hidden="true" class="octicon octicon-link"></span></a>References</h1> <p>[1] Cyclic redundancy check. In Wikipedia. Retrieved June 7th, 2020, from <a href="https://en.wikipedia.org/wiki/Cyclic_redundancy_check" rel="nofollow">https://en.wikipedia.org/wiki/Cyclic_redundancy_check</a>.</p> <p>[2] Mathematics of cyclic redundancy checks. In Wikipedia. Retrieved June 7th, 2020, from <a href="https://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks" rel="nofollow">https://en.wikipedia.org/wiki/Mathematics_of_cyclic_redundancy_checks</a></p> <p>[3] CRC Calculator. Bastian Molkenthin. Retrieved June 7th, 2020, from <a href="http://www.sunshine2k.de/coding/javascript/crc/crc_js.html" rel="nofollow">http://www.sunshine2k.de/coding/javascript/crc/crc_js.html</a></p> <h1> <a aria-hidden="true" class="anchor" href="#solicitation" id="user-content-solicitation"><span aria-hidden="true" class="octicon octicon-link"></span></a>Solicitation</h1> <p>How was your experience with this labs Suggestions are welcome in the form of a ticket on the course GitHub page: <a href="https://github.com/weaversa/cryptol-course/issues">https://github.com/weaversa/cryptol-course/issues</a></p> <h1> <a aria-hidden="true" class="anchor" href="#from-here-you-can-go-somewhere" id="user-content-from-here-you-can-go-somewhere"><span aria-hidden="true" class="octicon octicon-link"></span></a>From here, you can go somewhere!</h1> <table> <thead> <tr> <th align="right"></th> <th align="center"></th> <th></th> </tr> </thead> <tbody> <tr> <td align="right"></td> <td align="center"><a href="/README.html">^ Course README</a></td> <td></td> </tr> <tr> <td align="right"><a href="/labs/Language/Basics.html">&lt; Language Basics</a></td> <td align="center"><strong>CRC (Answers)</strong></td> <td><a href="/labs/Salsa20/Salsa20.html">Salsa20 &gt;</a></td> </tr> <tr> <td align="right"></td> <td align="center"><a href="/labs/CRC/CRC.html">? CRC</a></td> <td></td> </tr> </tbody> </table> </article> </div> </div> </div> </div> </div> </div>
