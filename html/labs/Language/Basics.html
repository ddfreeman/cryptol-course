<?xml version='1.0' encoding='UTF-8'?> <link href="/github-markdown-css/github-css.css" rel="stylesheet"/> <meta charset="utf-8" content="text/html"/> <div class="gist"> <style class="formula-style"> svg.gh-md-to-html-formula { fill: black; } </style> <div class="gist-file"> <!-- This is the class that is responsible for the boxing! --> <div class="gist-data"> <div class="js-gist-file-update-container js-task-list-container file-box"> <div class="file" id="article-Basics"> <div class="Box-body readme blob js-code-block-container p-5 p-xl-6" id="file-docker-image-pull-md-readme" style="margin-left: 40px; margin-right: 40px; margin-top: 20px; margin-bottom: 20px"> <article class="markdown-body entry-content container-lg" itemprop="text"> <h1> <a aria-hidden="true" class="anchor" href="#introduction" id="user-content-introduction"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introduction</h1> <p>This lab will provide a mostly comprehensive overview of those components of the Cryptol language needed to complete this course.</p> <h2> <a aria-hidden="true" class="anchor" href="#prerequisites" id="user-content-prerequisites"><span aria-hidden="true" class="octicon octicon-link"></span></a>Prerequisites</h2> <p>Before working through this lab, you'll need</p> <ul> <li>Cryptol to be installed,</li> <li>this module to load successfully, and</li> <li>an editor for completing the exercises in this file.</li> </ul> <h2> <a aria-hidden="true" class="anchor" href="#skills-youll-learn" id="user-content-skills-youll-learn"><span aria-hidden="true" class="octicon octicon-link"></span></a>Skills You'll Learn</h2> <p>By the end of this lab you will have a pretty good understanding of Cryptol's language constructs. At least good enough that you can come back here for reference as you work through the labs.</p> <p>Specifically, you'll also gain experience with</p> <ul> <li>Cryptol's module system,</li> <li>commenting,</li> <li>Cryptol's <code>Bit</code>, sequence, <code>Integer</code>, tuple, and record types,</li> <li>evaluating expressions,</li> <li>writing functions and properties,</li> <li>functions with curried parameters,</li> <li>type parameters and type constraints,</li> <li>the <code>:check</code>, <code>:prove</code>, and <code>:sat</code> commands,</li> <li>pattern matching,</li> <li>demoting types variables to value variables,</li> <li> <code>/\</code>, <code>\/</code>, <code>==&gt;</code> -- logical operations for single bits,</li> <li> <code>~</code>, <code>&amp;&amp;</code>, <code>||</code>, <code>^</code> -- logical operations for sequences,</li> <li> <code>==</code>, <code>!=</code> -- structural comparison,</li> <li> <code>==</code>, <code>&gt;=</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&lt;</code> -- nonnegative-word comparisons,</li> <li> <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>**</code> -- word-wise modular arithmetic,</li> <li> <code>&gt;&gt;</code>, <code>&lt;&lt;</code>, <code>&gt;&gt;&gt;</code>, <code>&lt;&lt;&lt;</code> -- shifts and rotates,</li> <li> <code>#</code> -- concatenation,</li> <li> <code>@</code>, <code>!</code>-- sequence indexing,</li> <li> <code>@@</code>, <code>!!</code> -- sequence indexing,</li> <li> <code>if then else</code> -- conditional expressions,</li> <li>manipulating sequences using <code>#</code>, <code>take</code>, <code>drop</code>, <code>split</code>, <code>join</code>, <code>head</code>, <code>last</code>, <code>tail</code>, <code>reverse</code>, <code>groupBy</code>, <code>map</code>, <code>iterate</code>, <code>scanl</code>, and <code>foldl</code>,</li> <li>the <code>sum</code> and <code>carry</code> operators,</li> <li>enumerations and sequence comprehensions, and</li> <li>lambda functions.</li> </ul> <h2> <a aria-hidden="true" class="anchor" href="#load-this-module" id="user-content-load-this-module"><span aria-hidden="true" class="octicon octicon-link"></span></a>Load This Module</h2> <p>This lab is a <a href="https://en.wikipedia.org/wiki/Literate_programming" rel="nofollow">literate</a> Cryptol document --- that is, it can be loaded directly into the Cryptol interpreter. Load this module from within the Cryptol interpreter running in the <code>cryptol-course</code> directory with:</p> <pre lang="Xcryptol"><code>Loading module Cryptol Cryptol&gt; :m labs::Language::Basics Loading module Cryptol Loading module labs::Overview::Overview Loading module labs::Language::Basics </code></pre> <p>We start by defining a new module for this lab:</p> <pre lang="cryptol"><code>module labs::Language::Basics where </code></pre> <p>You do not need to enter the above into the interpreter; the previous <code>:m ...</code> command loaded this literate Cryptol file automatically. In general, you should run <code>Xcryptol session</code> commands in the interpreter and leave <code>cryptol</code> code alone to be parsed by <code>:m ...</code>.</p> <h1> <a aria-hidden="true" class="anchor" href="#basic-use-of-the-cryptol-language" id="user-content-basic-use-of-the-cryptol-language"><span aria-hidden="true" class="octicon octicon-link"></span></a>Basic Use of the Cryptol Language</h1> <p>If you've programmed in a variety of languages (not just different <a href="https://en.wikipedia.org/wiki/Procedural_programming" rel="nofollow">procedural languages</a> descending from C), you'll find that, for the most part, Cryptol is just another language with a different vocabulary and a funky type system. After a little study you'll be able to do most anything computationally that you could otherwise, especially in the cryptographic realm. But once you are accustomed to Cryptol you will find that it is much easier to write correct cryptographic programs than with conventional languages. That's 'cause it's been tuned for such! To throw out the buzzwords:</p> <ul> <li>Cryptol is a <a href="https://en.wikipedia.org/wiki/Domain-specific_language" rel="nofollow">domain-specific language</a>. Not only does it have features to support its application domain, but also it elides a lot of junk that makes programming and analyzing the programs difficult.</li> <li>Cryptol has been designed with automated reasoning about code as a priority, so that we can leverage it for verification. Some things are harder to do in Cryptol, but they pay off in code that can be proven correct!</li> </ul> <p>In some ways this requires a new mind-set:</p> <ul> <li>Write properties about your functions.</li> <li> <code>:check</code> them.</li> <li>Try to <code>:prove</code> them when your function's definition has settled down.</li> </ul> <p>Enjoy getting addicted to this level of assurance!</p> <h2> <a aria-hidden="true" class="anchor" href="#preliminaries" id="user-content-preliminaries"><span aria-hidden="true" class="octicon octicon-link"></span></a>Preliminaries</h2> <p>Many of the concepts in this lab were briefly introduced in the <a href="../Overview/Overview.html">Overview</a> lab. This lab goes over many of those same concepts, but in much more depth. Consider this lab a resource that you may want to revisit as you work through the course material. Also consider keeping the <a href="https://github.com/GaloisInc/cryptol/blob/master/docs/ProgrammingCryptol.pdf">official Cryptol manual</a> close at hand.</p> <p>For examples in this lab, as they are displayed here, the warning messages about specifying bit sizes of numbers have been turned off. This is <strong>not</strong> something you should do when you're new at Cryptol; it's only done here for teaching purposes.</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; :set warnDefaulting = off </code></pre> <p>Also, some examples have octets as outputs that are easier to see as characters. To see octets as characters, turn on ASCII mode:</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; :set ascii = on </code></pre> <p>That makes any sequence of octets be displayed as the corresponding <a href="https://en.wikipedia.org/wiki/ASCII" rel="nofollow">ASCII</a> string in double quotes (<code>"</code>) and an octet outside a sequence be displayed as the corresponding ASCII character in single quotes (<code>'</code>). (This is mostly useful as a pedagogical aid.)</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; [0x63, 0x61, 0x74] "cat" labs::Language::Basics&gt; 0x78 'x' </code></pre> <p>The Cryptol interpreter parses <code>"abc"</code> and <code>[0x61, 0x62, 0x63]</code> into the exact same internal representation. <code>:set ascii = on</code> just causes the display of output to be ASCII strings or characters when appropriate, not unlike using <code>:set base = 10</code> to see numbers in base 10.</p> <h2> <a aria-hidden="true" class="anchor" href="#modules" id="user-content-modules"><span aria-hidden="true" class="octicon octicon-link"></span></a>Modules</h2> <p>This file is a Cryptol module. The first interpreted line of every Cryptol module must be <code>module Path::...Path::ModuleName where</code>. The <code>Path::...Path</code> component is the system path from the root of whatever set of modules you're creating or working from. The <code>ModuleName</code> component is the basename of this file. For instance, this module is <code>labs::Language::Basics</code> because its path from the root repository is <code>labs/Language/Basics.md</code>. There's really not much to naming modules. But don't forget the <code>where</code> clause at the end.</p> <p>Importing modules is also pretty simple. Just add a line starting with <code>import</code> followed by the name of the module. For example, here we import the <a href="../Overview/Overview.html">Overview lab</a>.</p> <pre lang="comment"><code>import labs::Overview::Overview </code></pre> <p>To avoid naming conflicts, or just generally improve readability, you can qualify the module import using the <code>as</code> clause.</p> <pre lang="cryptol"><code>import labs::Overview::Overview as OVLab </code></pre> <p>When the Cryptol interpreter loads the current lab (Basics), it gains access to all public definitions in the Overview lab.</p> <p>To keep a definition private, meaning it won't be imported by other modules, use the <code>private</code> clause.</p> <pre lang="cryptol"><code>private thisIsPrivate = 10 </code></pre> <p>Now all of the Overview lab definitions are accessed by prefixing <code>OVLab::</code>. For example,</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; :browse ... From labs::Overview::Overview ----------------------------- OVLab::decrypt : {a} (fin a) =&gt; [8] -&gt; [a][8] -&gt; [a][8] OVLab::encrypt : {a} (fin a) =&gt; [8] -&gt; [a][8] -&gt; [a][8] OVLab::sayHello : {a} (fin a) =&gt; [a][8] -&gt; [7 + a][8] ... labs::Language::Basics&gt; :set ascii=on labs::Language::Basics&gt; OVLab::sayHello "Victoria" "Hello, Victoria" </code></pre> <p>Imports can be further refined with <em>import lists</em>, which specify which definitions to include (or exclude) from the imported modules:</p> <pre lang="comment"><code>// imports `product` and `distinct` from the NQueens demo import labs::Demos::Cryptol::NQueens (product, distinct) // imports all _except_ the listed test definitions from the CRC spec import labs::CRC::CRC hiding ( CRCSimpleTest, testM, CRCSimple_QTest, CRCSimple_XFERTest, CRC32_BZIP2Test, CRC32_CTest, CRC32_DTest, CRC32_MPEG2Test, CRC32_POSIXTest, CRC32_QTest, CRC32_JAMCRCTest, CRC32_XFERTest ) // imports `littlendian`(`'`) functions, prefaced with `Salsa20::` import labs::Salsa20::Salsa20 as Salsa20 (littleendian, littleendian') // imports all except `inc` functions from `ProjectEuler` in `PE::` import labs::ProjectEuler::ProjectEuler as PE hiding (inc, inc1001) </code></pre> <p>Cryptol's module system also supports parameters, but that is covered in a later lab.</p> <h3> <a aria-hidden="true" class="anchor" href="#file-only-commands" id="user-content-file-only-commands"><span aria-hidden="true" class="octicon octicon-link"></span></a>File-only commands</h3> <p>It's worth noting that there are a very few Cryptol commands that can only be used in a file, <em>not</em> interactively in the interpreter. The most common of these are <code>module</code>, <code>import</code>, <code>private</code>, and <code>property</code>.</p> <h2> <a aria-hidden="true" class="anchor" href="#comments" id="user-content-comments"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comments</h2> <ul> <li> <code>//</code> comments to the to end of a line</li> <li> <code>/*</code> ... <code>*/</code> comments a block of code</li> </ul> <p>There is also a <a href="https://en.wikipedia.org/wiki/Docstring" rel="nofollow">docstring</a> comment facility (<code>/**</code> ... <code>*/</code> preceding a definition):</p> <pre lang="cryptol"><code>/** INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs A totally made up identifier for pedagogical purposes. It is INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs used elsewhere for demonstration of something or other. github-markdown-css/ html/ labs/ misc/ scripts/ specs/ mask = 7 : [32] </code></pre> <p>Now, when issuing <code>:help mask</code>, the above comments are displayed along with other information about <code>mask</code>.</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; :help mask mask : [32] A totally made up identifier for pedagogical purposes. It is used elsewhere for demonstration of something or other. </code></pre> <h2> <a aria-hidden="true" class="anchor" href="#variable-and-function-naming" id="user-content-variable-and-function-naming"><span aria-hidden="true" class="octicon octicon-link"></span></a>Variable and Function Naming</h2> <p>Cryptol identifiers (variable and function names) consist of alphanumeric characters plus <code>'</code> (apostrophe, but read "prime") and <code>_</code> (underscore). They must begin with an alphabetic character or an underscore. The notational convention for <code>'</code> is to indicate a related definition, while underscore is mostly used to separate words or as a catch-all for characters we'd like to use but are forbidden. <a href="https://en.wikipedia.org/wiki/Camel_case" rel="nofollow">Camel case</a> is often used when other naming constraints aren't mandated.</p> <pre lang="cryptol"><code>myValue = 15 : [32] myValue' = myValue &amp;&amp; mask // mask defined elsewhere </code></pre> <p>Feel free to take a quick look at the <a href="../../cryptol-style.html">Cryptol style guide</a> we used for creating the material in this course.</p> <p>Technically, Cryptol supports <a href="https://en.wikipedia.org/wiki/Unicode" rel="nofollow">Unicode</a>, but this course doesn't make use of that feature.</p> <h2> <a aria-hidden="true" class="anchor" href="#types-of-variables" id="user-content-types-of-variables"><span aria-hidden="true" class="octicon octicon-link"></span></a>Types of Variables</h2> <p>Cryptol's "basic" data type is an <em>n</em>-dimensional array (called a sequence) whose base type is bits.</p> <ul> <li>0-d: <code>False : Bit</code> and <code>True: Bit</code> </li> <li>1-d: Think bytes, words, nibbles, etc., i.e., a sequence of bits of any length usually thought of as a number. E.g., <code>0x2a : [8]</code>, <code>0b101010 : [6]</code> and <code>[False, True, False, True, False, True, False] : [7]</code>. These all compare as 42 in type appropriate contexts.</li> <li>2-d: Think sequences of 1-d objects all of the same size. E.g., <code>[42, 0b010101010101, 0xa5a, 0o5757] : [4][12]</code> </li> <li>3-d: Sequences of 2-d objects all of the same size. E.g., <code>[[0, 1], [1, 2], [3, 5], [8, 13]] : [4][2][4]</code> </li> <li>...</li> </ul> <p>Things to note:</p> <ul> <li> <p>The type of the lowest dimension of every sequence given above is <code>Bit</code>. It's correct to write <code>0x2a : [8]Bit</code>, but the <code>Bit</code> part of a sequence is implicit in Cryptol, otherwise we'd be writing the word <code>Bit</code> at the end of just about every type. So, <code>Bit</code> is often left off when writing the types of sequences.</p> </li> <li> <p>There are no privileged bit widths in Cryptol. <code>[13]</code> is just as good a type as <code>[8]</code>, <code>[16]</code>, <code>[32]</code> or <code>[64]</code>.</p> </li> <li> <p>There's <code>0b...</code> for binary, <code>0o...</code> for octal and <code>0x...</code> for hexadecimal.</p> </li> <li> <p>Lengths of sequences may be zero. Zero length sequences act as an identity for concatenation and are useful in padding.</p> </li> <li> <p>The possible values by type:</p> <ul> <li> <code>[0]</code> --- <code>0</code> </li> <li> <code>[1]</code> --- <code>0</code> and <code>1</code> </li> <li> <code>[2]</code> --- <code>0</code>, <code>1</code>, <code>2</code> and <code>3</code> </li> <li>...</li> <li> <code>[n]</code> --- <code>0</code> through <code>2^^n - 1</code> </li> </ul> </li> <li> <p>There are 2<sup><em>n</em></sup> values of type <code>[n]</code>. There are 2<sup><em>mn</em></sup> values of type <code>[m][n]</code>, etc.</p> </li> <li> <p>1-d sequences of bits are treated as numbers by arithmetic and comparison operators. So for instance, <code>[False, True] == (1 : [2])</code> and <code>[True, False, True] &gt; 4</code> both hold.</p> </li> <li> <p>Cryptol distinguishes between different dimensions. In particular, <code>True</code> and <code>[True]</code> are type incompatible.</p> </li> <li> <p>The number of bracket pairs in a type gives its dimension.</p> </li> <li> <p>Cryptol supports <strong>holes</strong> in types via the <code>_</code> character. When Cryptol encounters a hole, it will try to infer a value. Notice in the example below how Cryptol <em>fills in</em> the <code>3</code> where we left an underscore.</p> </li> </ul> <pre lang="Xcryptol"><code> labs::Language::Basics&gt; [1, 2, 3] : [_][32] [0x00000001, 0x00000002, 0x00000003] labs::Language::Basics&gt; :type [1, 2, 3] : [_][32] ([1, 2, 3] : [_][32]) : [3][32] </code></pre> <p>Other data types include:</p> <ul> <li>Arbitrary-precision integers: E.g., <code>2^^1023 - 347835479 : Integer</code> </li> <li>Heterogeneous tuples: E.g.: <code>(False, 0b11) : (Bit, [2])</code> and <code>(True, [1, 0], 7625597484987) : (Bit, [2][1], Integer)</code> <ul> <li>Elements of tuples are accessed by <code>.0</code>, <code>.1</code>, ...</li> </ul> </li> </ul> <pre lang="Xcryptol"><code> labs::Language::Basics&gt; (False, 0b11).0 False </code></pre> <ul> <li>Records with named fields: E.g., <code>{flag = True, x = 2} : {flag : Bit, x : [4]}</code> <ul> <li>Elements of records are accessed by <code>.</code> followed by the field name.</li> </ul> </li> </ul> <pre lang="Xcryptol"><code> labs::Language::Basics&gt; {flag = True, x = 2}.flag True </code></pre> <ul> <li>Integers modulo <em>n</em>: Each type of the form <code>[n]</code>, described above, provides a <a href="https://en.wikipedia.org/wiki/Modular_arithmetic#Residue_systems" rel="nofollow">least residue system</a> for <a href="https://en.wikipedia.org/wiki/Modular_arithmetic#Integers_modulo_n" rel="nofollow">integers modulo 2<sup>n</sup></a>. Types of the form <code>Z n</code> provide a least residue system for any positive <em>n</em>. E.g., <code>4 + 4 : Z 7</code> evaluates to <code>1</code>.</li> </ul> <p>Though Cryptol supports a slew of different data types, most are not needed to be successful in this course. Specifically, this course makes heavy use of sequences, with the occasional tuple and <code>Integer</code> thrown in.</p> <p><strong>EXERCISE</strong>: The Cryptol interpreter command <code>:type</code> (or <code>:t</code> for short) is very useful for helping understand types. Use the <code>:type</code> command in the interpreter to determine the types of the variables defined below. (<em>Recall that these variables have been instantiated as a result of loading this module via <code>:module</code>.</em>)</p> <pre><code>varType0 = False varType1 = [False] varType2 = [False, False, True] varType3 = 0b001 varType4 = [0x1, 2, 3] varType5 = [ [1, 2, 3 : [8]] , [4, 5, 6], [7, 8, 9] ] varType6 = [ [1, 2, 3] : [3][8], [4, 5, 6], [7, 8, 9] ] varType7 = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] : [_][_][8] varType8 = (0b1010, 0xff) varType9 = [ (10 : [12], [1, 2 : [4], 3], ([0b101, 7], 0xab)), (18 : [12], [0, 1 : [4], 2], ([0b100, 3], 0xcd)) ] </code></pre> <p>For this next set, challenge yourself by filling in your guesses ahead of time, writing your answers inline below. If you fill in the wrong type, Cryptol will complain when reloading the file in the interpreter. For example, say you provided the following type to the previous <code>varType0</code> variable:</p> <pre lang="comment"><code>varType0 = False : [10] </code></pre> <p>When you reload this file in the interpreter, you will see the following error:</p> <pre lang="Xcryptol"><code> Type mismatch: Expected type: [10] Inferred type: Bit </code></pre> <p>Here, Cryptol is telling you that it <strong>expected</strong> the value <code>False</code> to be a 10-bit sequence (because that's what we told Cryptol). However, Cryptol <strong>inferred</strong> that the type of <code>False</code> is actually <code>Bit</code>.</p> <p>The types of the variables you viewed above were all <em>monomorphic</em>, meaning there was only a single valid type for each variable. Recall that numbers can be represented using a lot of different types. For instance, the number <code>5</code> can be an <code>Integer</code>, a 32-bit bitvector, or even a 12039780-bit bitvector (with 12039777 leading <code>0</code> bits). So, when you ask for the type of <code>5</code> in the interpreter, you'll see:</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; :t 5 5 : {a} (Literal 5 a) =&gt; a </code></pre> <p>That letter <code>a</code> inside curly braces is a type variable. When you see a number (or a function) whose type is stated using a type variable (here, <code>a</code>), it means there is some freedom in the type of the value variable (here, <code>5</code>). For the next set of exercises, you'll be asked to type some variables monomorphically; that is, you shouldn't need any curly braces or <code>=&gt;</code> symbols when you specify the types. That's all stuff that's covered later in this section.</p> <p><strong>EXERCISE</strong>: Fill in <em>any valid monomorphic</em> type for each of the values below. Some will have multiple correct answers. Once done, <code>:reload</code> this file to check that you've gotten them correct.</p> <pre><code>varType10 = 0x1234 varType11 = 10 varType12 = [1, 2, 0x7] varType13 = (1, 2, 0x7) varType14 = [ (1, 2), (3, 4 : Integer), (5 : [10], 6) ] varType15 = [ 1, 2, 3, 4, 5, 6, 7, 9, 10, 11, 12 : [8], 13, 14, 15 ] varType16 = ([10, 9, 8], [7, 6, 5, 0b0100]) varType17 = [] varType18 = () varType19 = ([((),()), ((),())], [[[]]], ([[]], [[]])) </code></pre> <p>That last one is a really good demonstration of what to avoid when writing specifications! Honestly, most of those look such a mess that it's now obligatory to point out that:</p> <blockquote> <p><strong>Specifications are supposed to be easily understood</strong>.</p> </blockquote> <p>It's simply bad form to mix numerical representations, put type parameters in the middle of sequences, and so on. Please don't take these exercises to be considered <em>good</em> Cryptol. They were crafted to challenge you, something you should <strong>never</strong> do to someone who wants to use the specifications you write. Always strive to make elegant specifications. There is no need to optimize for performance. Also, don't write a spec "just to get it done" -- making something that loads and runs isn't good enough. Aim for creating specifications that <em>look</em> like the mathematics you're specifying. &lt; rant over &gt;</p> <h2> <a aria-hidden="true" class="anchor" href="#types-of-functions" id="user-content-types-of-functions"><span aria-hidden="true" class="octicon octicon-link"></span></a>Types of Functions</h2> <p>What would a programming language be without the ability to write functions? Since Cryptol is a pure functional language, functions are stateless (side-effect free) definitions that map each (valid) input to an output.</p> <p>Here is an example of a function called <code>add</code> that takes two arguments <code>x</code> and <code>y</code> and adds them together.</p> <pre lang="comment"><code>add x y = x + y </code></pre> <p>As it stands, this function works with many different types of <code>x</code> and <code>y</code>. For instance, it will work with <code>x</code> and <code>y</code> both <code>Integers</code>, both 13-bit bitvectors, and (believe it or not) even with both as tuples of sequences. Since this function accepts many different types of arguments, it's called <a href="https://en.wikipedia.org/wiki/Polymorphism_(computer_science)" rel="nofollow">polymorphic</a>:</p> <blockquote> <p>provi[ding] a single interface to entities of different types.</p> </blockquote> <p>Oftentimes, cryptographic functions are written to only work with specified types (such as having a 256-bit key), and we want to capture that information in our specifications. Hence, Cryptol functions can be typed, much the same way as typing variables (in the previous section). To do so, we add a type definition to the function we're defining. For an example, here we make our <code>add</code> function only work on 32-bit bitvectors:</p> <pre lang="comment"><code>add : [32] -&gt; [32] -&gt; [32] add x y = x + y </code></pre> <p>Type definitions start with the name of the function followed by a colon. Next, one can <em>optionally</em> define some type variables and levy constraints on them (we describe this later). Then the types of the input variables are given, separated by <code>-&gt;</code>. Finally the type of the output is given.</p> <p>And we can ask for the type of functions using <code>:type</code>, just like we asked for the types of variables.</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; :type add add : [32] -&gt; [32] -&gt; [32] </code></pre> <h3> <a aria-hidden="true" class="anchor" href="#curried-and-uncurried-style" id="user-content-curried-and-uncurried-style"><span aria-hidden="true" class="octicon octicon-link"></span></a>Curried and Uncurried Style</h3> <p>Cryptol functions are often written in the <a href="https://en.wikipedia.org/wiki/Currying" rel="nofollow">curried</a> style:</p> <pre lang="cryptol"><code>add : [32] -&gt; [32] -&gt; [32] add x y = x + y </code></pre> <p>rather than:</p> <pre lang="cryptol"><code>addUncurried : ([32], [32]) -&gt; [32] addUncurried (x, y) = x + y </code></pre> <p>These two functions would be applied as shown:</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; add 20 28 48 labs::Language::Basics&gt; addUncurried (20, 28) 48 </code></pre> <p>There's also native support in Cryptol for currying and uncurrying.</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; curry addUncurried 20 28 48 labs::Language::Basics&gt; uncurry add (20, 28) 48 </code></pre> <p>Hopefull you can see that these two styles are equivalent at some level. Curried functions are preferred as they afford <a href="https://en.wikipedia.org/wiki/Partial_application" rel="nofollow">partial application</a>, but uncurried can be useful for explicating the correspondence to functions from other languages or documents.</p> <ul> <li>If it helps you, mentally read curried functions like this: input argument types are all prior to the last arrow, and the result type follows the last arrow. Pictorially: <code>in -&gt; in -&gt; ... -&gt; in -&gt; out</code>.</li> <li>Partial application lets one form a new function from an old one where an argument is fixed. For instance, <code>add 1</code> is a function itself!</li> </ul> <pre lang="cryptol"><code>increment = add 1 </code></pre> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; :t increment increment : [32] -&gt; [32] labs::Language::Basics&gt; increment 10 11 </code></pre> <p><code>add 1</code> takes a 32-bit bitvector and returns a 32-bit bitvector. When it is applied to a 32-bit bitvector, it adds one to that bitvector. Other examples to illustrate partial application:</p> <ul> <li> <code>addUncurried</code> is really a function of one argument. It happens that the argument is a tuple, which makes <code>addUncurried (28, 20)</code> look just like a two argument function in many languages.</li> </ul> <p><strong>EXERCISE</strong>: Use the <code>:type</code> command in the interpreter to discover the types of the following functions.</p> <pre><code>funType0 a = a + 7 : [5] funType1 a b = a + b + 0b0011100 funType2 a b = (a + 0x12, b + 0x1234) funType3 (a, b) = (a + 0x12, b + 0x1234) funType4 ((a, b), c) = c + 10 : [32] funType5 [a, b, c : [10]] = [a, b, c] funType6 (a : [3][10]) = [a@0, a@1, a@2] //Fun fact! funType5 and funType6 compute the same function. //Try, :prove funType5 === funType6 funType7 x = (x, x, [ [[False, True], x], [x, x], [x, x] ]) funType8 = funType2 10 funType9 = False //Is this a function with no arguments, or a value? Hmmmm...is there a difference? Nope! </code></pre> <p>Now that you have some experience <em>viewing</em> function types, you're about to be asked to write some. Here are a few common mistakes, and what the error messages look like in the interpreter:</p> <p>Say we accidentally added a two input type to <code>funType0</code>:</p> <pre lang="comment"><code>funType0 : [5] -&gt; [5] -&gt; [5] funType0 a = a + 7 : [5] </code></pre> <p>Upon reloading this file, we would see:</p> <pre lang="Xcryptol"><code> Type mismatch: Expected type: [5] -&gt; [5] Inferred type: [5] </code></pre> <p>Here Cryptol is telling us that Cryptol <strong>expected</strong> (based on the type definition) the type of input <code>a</code> to take two 5-bit bitvectors. But, Cryptol <strong>inferred</strong> (from the value definition) that the function just takes a single 5-bit bitvector.</p> <p>Say we accidentally added the wrong type:</p> <pre lang="comment"><code>funType0 : [4] -&gt; [12] funType0 a = a + 7 : [5] </code></pre> <p>Upon reloading this file, we would see:</p> <pre lang="Xcryptol"><code> Type mismatch: Expected type: 5 Inferred type: 4 Type mismatch: Expected type: 12 Inferred type: 5 </code></pre> <p>Now we get two error messages. One is complaining about the input type, the other about the output type.</p> <p><strong>EXERCISE</strong>: Just like in the previous section, you're now being asked to fill in <em>any valid monomorphic</em> type for each of the functions below. Some will have multiple correct answers. Once done, reload this file to check that you've gotten them correct.</p> <pre><code> funType10 x = x + x : [10] funType11 a b = [a : Bit, b, b] funType12 [a, b] = [a : Bit, b, b] funType13 (a, b) = [a : Bit, b, b] funType14 a b ([c, d], e) = [ (a , [b, b, b]), ([d, d], [c, c, c]), (a , e) ] funType15 a b = [ a, b, a, b, a, b, a, b, a, b, a, b, a, b, a, b, a, b, a, b, a, b, a, b, a, b, a, b, a, b, a, b, a, b, a, b, a, b, a, b, a, b ] funType16 a b = [ [ a, b, a, b, a, b ], [ a, b, a, b, a, b ], [ a, b, a, b, a, b ], [ a, b, a, b, a, b ], [ a, b, a, b, a, b ], [ a, b, a, b, a, b ], [ a, b, a, b, a, b ] ] funType17 a b = ( [ a, b, a, b, a, b ], [ a, b, a, b, a, b ], [ a, b, a, b, a, b ], [ a, b, a, b, a, b ], [ a, b, a, b, a, b ], [ a, b, a, b, a, b ], [ a, b, a, b, a, b ] ) funType18 a b = [ ( a, b, a, b, a, b ), ( a, b, a, b, a, b ), ( a, b, a, b, a, b ), ( a, b, a, b, a, b ), ( a, b, a, b, a, b ), ( a, b, a, b, a, b ), ( a, b, a, b, a, b ) ] funType19 a b = ( ( a, b, a, b, a, b ), ( a, b, a, b, a, b ), ( a, b, a, b, a, b ), ( a, b, a, b, a, b ), ( a, b, a, b, a, b ), ( a, b, a, b, a, b ), ( a, b, a, b, a, b ) ) // We're so sorry </code></pre> <p>After that set of exercises, you likely see the conciseness of the sequence type over the tuple type (it was hammered in pretty hard there at the end). Lesson: don't use tuples unless you really really have to. Curry your parameters and group heterogeneous elements together in sequences. Tuples are only really useful when you want a function to output multiple values that have different types.</p> <h3> <a aria-hidden="true" class="anchor" href="#pattern-matching" id="user-content-pattern-matching"><span aria-hidden="true" class="octicon octicon-link"></span></a>Pattern Matching</h3> <p>You've no doubt noticed by now that the left-hand side of assignment statements aren't restricted to just single variables. This flexibility comes from Cryptol's powerful <strong>pattern matching</strong> capabilities. Cryptol allows you to make assignments by writing patterns based on the type (<em>shape</em>) of the value on the right-hand side. Again, <code>_</code> acts as a kind of hole (when it's by itself, not when it's part of an identifier, of course). For example:</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; let (fst, snd) = (4, 5) labs::Language::Basics&gt; fst 4 labs::Language::Basics&gt; snd 5 labs::Language::Basics&gt; let r = (0xa, 0xb) labs::Language::Basics&gt; r (0xa, 0xb) labs::Language::Basics&gt; let (fst, snd) = r labs::Language::Basics&gt; fst 0xa labs::Language::Basics&gt; snd 0xb labs::Language::Basics&gt; let [ (a, b, _), (_, _, c), _ ] = [ (1, 2, 3), (4, 5, 6), (7, 8, 9) ] : [3]([4], [4], [4]) labs::Language::Basics&gt; a 0x1 labs::Language::Basics&gt; b 0x2 labs::Language::Basics&gt; c 0x6 </code></pre> <p>Cryptol can even pattern match on sequence concatenation; for example:</p> <pre lang="cryptol"><code>firstThreeBits : {n} [3 + n]-&gt; [3] firstThreeBits ([a, b, c] # xs) = [a, b, c] </code></pre> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; :s base=2 labs::Language::Basics&gt; firstThreeBits 0b1100111 0b110 </code></pre> <h3> <a aria-hidden="true" class="anchor" href="#polymorphic-functions" id="user-content-polymorphic-functions"><span aria-hidden="true" class="octicon octicon-link"></span></a>Polymorphic Functions</h3> <p>Sometimes, though not often, cryptographic functions are parameterized on the type of an input. For example, the <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard" rel="nofollow">Advanced Encryption Standard (AES)</a> accepts key sizes of 128, 192, and 256 bits. Also, stream ciphers and hash functions work over arbitrary sized streams of input. So, in general, the full type of a function looks something like the following. (For the numbered identifiers, we limit ourselves to two examples, but in reality there can be any number.)</p> <pre lang="comment"><code>functionName : {typeVariable0, typeVariable1} (typeConstraint0, typeConstraint1) =&gt; inputType0 -&gt; inputType1 -&gt; outputType </code></pre> <p>Here's an English-language breakdown:</p> <table> <thead> <tr> <th></th> <th></th> </tr> </thead> <tbody> <tr> <td><code>functionName</code></td> <td><code>:</code></td> </tr> <tr> <td>The function <code>functionName</code> </td> <td>has a type</td> </tr> </tbody> </table> <table> <thead> <tr> <th></th> </tr> </thead> <tbody> <tr> <td> <code>{</code> <code>typeVariable0</code> <code>,</code> <code>typeVariable1</code> <code>}</code> </td> </tr> <tr> <td>with type variables <code>typeVariable0</code> and <code>typeVariable1</code> </td> </tr> </tbody> </table> <table> <thead> <tr> <th></th> <th></th> </tr> </thead> <tbody> <tr> <td> <code>(</code> <code>typeConstraint0</code> <code>,</code> <code>typeConstraint1</code> <code>)</code> </td> <td><code>=&gt;</code></td> </tr> <tr> <td>and the constraints <code>typeConstraint0</code> and <code>typeConstraint1</code> </td> <td>applied to the type definition</td> </tr> </tbody> </table> <table> <thead> <tr> <th></th> <th></th> <th></th> <th></th> <th></th> </tr> </thead> <tbody> <tr> <td><code>inputType0</code></td> <td><code>-&gt;</code></td> <td><code>inputType1</code></td> <td><code>-&gt;</code></td> <td><code>outputType</code></td> </tr> <tr> <td>that takes <code>inputType0</code> </td> <td>and</td> <td><code>inputType1</code></td> <td>and returns</td> <td><code>outputType</code></td> </tr> </tbody> </table> <p>Let's make an example to work with:</p> <pre lang="comment"><code>sayHello: {n} (fin n) =&gt; [n][8] -&gt; [7+n][8] sayHello name = "Hello, " # name </code></pre> <p>And the breakdown:</p> <table> <thead> <tr> <th></th> <th></th> <th></th> <th></th> <th></th> <th></th> <th></th> <th></th> </tr> </thead> <tbody> <tr> <td><code>sayHello</code></td> <td><code>:</code></td> <td> <code>{</code> <code>n</code> <code>}</code> </td> <td> <code>(</code> <code>fin n</code> <code>)</code> </td> <td><code>=&gt;</code></td> <td><code>[n][8]</code></td> <td><code>-&gt;</code></td> <td><code>[7+n][8]</code></td> </tr> <tr> <td>The function <code>sayHello</code> </td> <td>has a type</td> <td>with type variable <code>n</code> </td> <td>and the constraint that <code>n</code> is finite</td> <td>applied to the type definition</td> <td>that takes a list of <code>n</code> <code>8</code>-bit vectors</td> <td>and returns</td> <td>a list of <code>7+n</code> <code>8</code>-bit vectors</td> </tr> </tbody> </table> <p>This function's name is <code>sayHello</code>, it takes in a sequence called <code>name</code> that is <code>n</code> octets long and produces a sequence that is <code>7+n</code> octets long, where <code>n</code> is finite. The function itself outputs the concatenation (using the <code>#</code> operator) of the string "Hello, " with the value of <code>name</code>. If we wanted to enforce that the length of <code>n</code> was less than some value, we could add another constraint, like so:</p> <pre lang="cryptol"><code>sayHello: {n} (n &lt;= 12) =&gt; [n][8] -&gt; [7+n][8] sayHello name = "Hello, " # name </code></pre> <p>Now, since <code>n</code> is less than or equal to twelve, it's clearly finite, so the <code>fin n</code> constraint is extraneous. We could leave it, Cryptol won't complain, but it's nice to be as concise as possible when typing functions. A list of all available type constraints can be found by typing <code>:browse</code> into the interpreter and looking for the "Primitive Types" section. You can also ask for <code>:help</code> on any of these, for example:</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; :h fin primitive type fin : # -&gt; Prop Assert that a numeric type is a proper natural number (not 'inf'). </code></pre> <p>Let's use the interpreter to send a few values through <code>sayHello</code> and see what happens.</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; :s ascii=on labs::Language::Basics&gt; sayHello "Munkustrap" "Hello, Munkustrap" labs::Language::Basics&gt; sayHello "Skimbleshanks" [error] at &lt;interactive&gt;:1:1--1:25: Unsolvable constraints: • 12 &gt;= 13 arising from use of expression sayHello at &lt;interactive&gt;:1:1--1:9 • Reason: It is not the case that 12 &gt;= 13 </code></pre> <p>Here we see that <code>sayHello</code> happily accepts a 10-octet sequence but wholeheartedly rejects a 13-octet sequence. This is the type system in action! Let's also briefly take a look at the type for the concatenation operator <code>#</code>.</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; :t (#) (#) : {front, back, a} (fin front) =&gt; [front]a -&gt; [back]a -&gt; [front + back]a </code></pre> <p>We can pretty accurately guess what this function is doing just by looking at its type. Here we see that <code>#</code> takes two arguments. The first is a sequence of <code>front</code> many elements of type <code>a</code>. The second is a sequence of <code>back</code> many elements, also of type <code>a</code>. The function returns a sequence of <code>front + back</code> many elements, again of type <code>a</code>. The type variable <code>a</code> is unconstrained (there are no type constraints levied on it) and so <code>#</code> will accept sequences of any type --- a sequence of bits, a sequence of sequences, a sequence of tuples, etc. The <code>fin front</code> constraint tells us that the first sequence has to have a finite number of elements, and the absence of constraints on <code>back</code> means that the second argument can have any number (even an infinite number) of elements. Since sequences (in some sense) start from the left, it doesn't make sense to concatenate something onto the back of an infinite sequence, but it seems perfectly fine to concatenate something onto the front of an infinite sequence.</p> <p>All that aside, the <code>sayHello</code> example above is a bit silly, but when utilized fully, the type system acts to protect functions from being called in a way that is potentially harmful. For example, let's say we had a function that accesses the 12th bit of a bitvector. This can be achieved using Cryptol's <code>@</code> operator which performs 0-based indexing from the left (indexing sequences is explained in more detail later on). The type system should be used to make sure that such a function can only be called with bitvectors with at least 13 bits, like so:</p> <pre lang="cryptol"><code>bitTwelve : {n} (fin n, n &gt;= 13) =&gt; [n] -&gt; Bit bitTwelve x = x@12 </code></pre> <p>Let's use the interpreter to send a few values through <code>bitTwelve</code> and see what happens.</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; bitTwelve 0b101100101001 [error] at &lt;interactive&gt;:1:1--1:25: Unsolvable constraints: • 12 &gt;= 13 arising from use of expression bitTwelve at &lt;interactive&gt;:1:1--1:10 • Reason: It is not the case that 12 &gt;= 13 labs::Language::Basics&gt; bitTwelve 0b1010101010100100101010101010101010101 False </code></pre> <p>As expected, the type constraint forces the function to only accept bitvectors with more than 12 bits.</p> <p>For this course, we restrict ourselves to type variables and constraints involved with sequences. This means (while you work through the material here) you can always think about type variables as representing the <strong>sizes</strong> (or length) of sequences, and type constraints as constraints on those sizes. Type variables and constraints can represent more, but these extensions are not used or covered in this course.</p> <p>With this idea in mind (type variables as sizes), many procedural programming languages treat the sizes of sequences as value variables . For example, in C, one needs to pass the length of an array as a value variable, like so:</p> <div class="highlight highlight-source-c"><pre><span class="pl-k">int</span> <span class="pl-en">F</span> (<span class="pl-k">int</span> *array, <span class="pl-k">int</span> size)</pre></div> <p>And <code>F</code> has to trust that the length of <code>array</code> really is <code>size</code>. Whereas in Cryptol we would write <code>F</code> as:</p> <pre lang="comment"><code>F : {size} (fin size) =&gt; [size][32] -&gt; [32] </code></pre> <p>In Cryptol, <code>array</code> and <code>size</code> are different classes of variables, and they are strongly linked so that <code>F</code> doesn't have to trust that the length of <code>array</code> really is <code>size</code>. This kind of linkage is called <a href="https://en.wikipedia.org/wiki/Strong_and_weak_typing" rel="nofollow">Strong typing</a> and generally refers to use of programming language types in order to both capture invariants of the code, and ensure its correctness, and definitely exclude certain classes of programming errors.</p> <p>Now, because there are two classes of variables, type variables and value variables, there are distinct ways of passing them to a function. The material above demonstrated passing value variables. We'll now demonstrate how to pass type variables using the backtick <code>`</code> character (usually on a key shared with <code>~</code> positioned in the upper left of the keyboard) and curly braces <code>{}</code>.</p> <p>Let's make a function that repeats a value of type <code>a</code> exactly <code>n</code> times, where <code>a</code> and <code>n</code> are type variables. To create a repeating sequence, this function uses what's called a <strong>sequence comprehension</strong>, but you can ignore that for now; it gets covered later.</p> <p>(To clarify: The value of the type variable <code>n</code> will be a number. The value of the type variable <code>a</code> will be a type, such as Bit or [16]. This value of <code>a</code> will be the type of the value that will get repeated. That value to be repeated is input as the argument of the <code>repeat</code> function.)</p> <pre lang="cryptol"><code>repeat : {n, a} () =&gt; a -&gt; [n]a repeat value = [ value | _ &lt;- zero : [n] ] </code></pre> <p><strong>EXERCISE</strong>: Here are a few examples demonstrating how to pass type and value variables to this function. Please try typing these examples into the interpreter and consider the output, and trying your own examples as curiosity strikes you.</p> <p>To clarify some of the terminology used here: In Cryptol, when we speak of “passing a variable,” it’s basically a short way to say “passing the value of (that) variable.” This applies both to passing a type variable/ passing the value of a type variable, and to passing a value variable/ passing the value of a value variable. (The shorter form is in a sense more abstract, though.)</p> <p>For instance, in the first example below (<code>polyType0</code>), we pass two type variables to the <code>repeat</code> function as parameters, namely, <code>a</code> and <code>n</code>.<br/> But specifically, we pass their values <code>[64]</code> and <code>2</code>, respectively. We also pass to the <code>repeat</code> function the value <code>7</code> as its argument.</p> <pre lang="cryptol"><code>polyType0 = repeat`{a=[64], n=2} 7 polyType1 = repeat`{n=4, a=[64]} 7 polyType2 = repeat`{a=Bit, n=20} True polyType3 = repeat`{n=20, a=Bit} True polyType4 = repeat`{n=20} True polyType5 = repeat`{n=4, a=[2][3]} zero polyType6 = repeat`{n=4, a=[3][7]} [1, 2, 3] polyType7 = repeat`{n=4} ([1, 2, 3] : [3][7]) polyType8 = repeat 7 : [5][16] polyType9 = repeat`{a=[16]} 7 : [5][_] polyType10 = repeat`{n=5} 7 : [_][16] polyType11 = repeat`{a=[16], n=5} 7 polyType12 = repeat`{5, [16]} 7 polyType13 = repeat`{5} (7 : [16]) </code></pre> <p>You'll notice that you can either pass type variable values or let Cryptol infer the type variable values from the type of the output. Also, those last two examples demonstrate that you can pass type parameters based on position, that is, since the type of repeat declares <code>{n, a}</code> as type variables <strong>in that order</strong> (<code>n</code> first, then <code>a</code> second), Cryptol will infer which value goes with which type variable based on its position inside the curly braces, so you don't need to provide the <code>name=</code> part.</p> <p><strong>EXERCISE</strong>: Write a function called <code>zeroPrepend</code> that prepends <code>n</code> <code>False</code> bits onto the beginning of an <code>m</code>-bit bitvector called <code>input</code>. You'll need to use the <code>#</code> operator. Feel free to use the <code>repeat</code> function we wrote above, though there are solutions that don't require it.</p> <p>(Note: Many times in this course you will be asked to do a coding exercise in which your assignment is to alter a snippet of code. If when doing so you find you need to start over, but you have saved over the original code snippet and do not know what the original looked like, you may find the original by locating the current module in the course repository on <a href="https://github.com/weaversa/cryptol-course">GitHub</a>.)</p> <pre lang="cryptol"><code>// Uncomment and fill in //zeroPrepend : {} (?) =&gt; ? -&gt; ? zeroPrepend input = undefined </code></pre> <p>Check your function by running these tests in the interpreter and seeing that you get the same results:</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; :s base=2 labs::Language::Basics&gt; zeroPrepend`{n=7} 0b111 0b0000000111 labs::Language::Basics&gt; zeroPrepend`{n=3, m=inf} zero [False, False, False, False, False, ...] labs::Language::Basics&gt; zeroPrepend`{m=6} 5 : [10] 0b0000000101 labs::Language::Basics&gt; zeroPrepend`{5, 6} 15 0b00000001111 labs::Language::Basics&gt; :s base=16 </code></pre> <h3> <a aria-hidden="true" class="anchor" href="#demoting-types-to-values" id="user-content-demoting-types-to-values"><span aria-hidden="true" class="octicon octicon-link"></span></a>Demoting Types to Values</h3> <p>Because type variables and value variables are different classes of variables, they cannot interact directly (for example, we cannot write an expression equating the two). If we think of these two classes being in a hierarchy, type variables would be above value variables. With this hierarchy in mind, Cryptol does allow type variables to be <strong>demoted</strong> to value variables, but value variables cannot be promoted to type variables. For example, the following is not possible.</p> <pre lang="comment"><code>notPossible size = 0 : [size] </code></pre> <p>We cannot go from a value variable (<code>size</code> on the left) up to a type variable (<code>size</code> on the right). However, we can go down by using the backtick <code>`</code> character. For example:</p> <pre lang="cryptol"><code>appendSize : {size} (fin size, 32 &gt;= width size) =&gt; [size][32] -&gt; [size+1][32] appendSize input = input # [`size] </code></pre> <p>Here we concatenate the size of a sequence onto the end of that sequence. To read the function definition more verbatim:</p> <blockquote> <p><code>appendSize</code> takes an input named <code>input</code> that is a sequence of <code>size</code> number of 32-bit elements and outputs a sequence of <code>size+1</code> 32-bit elements, where the first <code>size</code> elements are <code>input</code> and the last element is the size of the input sequence.</p> </blockquote> <p>When type variables are demoted to value variables, they must take on a type. Cryptol usually infers the correct type, and in this case <code>`size</code> becomes a 32-bit value. It is because of this that the function has <code>32 &gt;= width size</code> as a type constraint. If <code>size</code> were greater than <code>2^^32</code>, it couldn't be demoted into a 32-bit value because it wouldn't fit! So, the demotion here forces us to add this extra type constraint. Luckily, if you forget to add such things, Cryptol will generally complain and let you know what you forgot. For example, if we remove that constraint and reload this file we see:</p> <pre lang="Xcryptol"><code> Failed to validate user-specified signature. in the definition of 'appendSize', at Basics.md:923:1--923:11, we need to show that for any type size assuming • fin size the following constraints hold: • 32 &gt;= width size arising from use of literal or demoted expression </code></pre> <p>This essentially says that Cryptol won't accept the function unless we add the constraint that <code>32 &gt;= width size</code>, or some stronger constraint --- we could, if we wanted, add that <code>size &lt; 7</code> as it subsumes the more general constraint that Cryptol is inferring.</p> <p>As a quick aside, you may be wondering why <code>`size</code> is inside brackets (<code>[]</code>). This is due to the fact that Cryptol can only concatenate sequences that are the same dimension. <code>input</code> is a 2-dimensional sequence, and <code>`size</code> is a 1-dimensional sequence. So we surround it in brackets (<code>[`size]</code>) to turn it from a 32-bit bitvector into a sequence of one 32-bit bitvector (a 2-dimensional sequence).</p> <h3> <a aria-hidden="true" class="anchor" href="#type-synonyms" id="user-content-type-synonyms"><span aria-hidden="true" class="octicon octicon-link"></span></a>Type synonyms</h3> <p>You can define type synonyms using the <code>type</code> keyword. For example</p> <pre lang="cryptol"><code>type myType x = [x][x] </code></pre> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; :s base=2 labs::Language::Basics&gt; zero : myType 2 [0b00, 0b00] labs::Language::Basics&gt; zero : myType 5 [0b00000, 0b00000, 0b00000, 0b00000, 0b00000] </code></pre> <h2> <a aria-hidden="true" class="anchor" href="#judicious-type-system-usage" id="user-content-judicious-type-system-usage"><span aria-hidden="true" class="octicon octicon-link"></span></a>Judicious Type System Usage</h2> <h3> <a aria-hidden="true" class="anchor" href="#dont-let-the-type-system-do-your-work" id="user-content-dont-let-the-type-system-do-your-work"><span aria-hidden="true" class="octicon octicon-link"></span></a>Don't let the type system do your work</h3> <p>Cryptol's type system tries to infer the types of functions lacking a type signature. Sometimes it comes up with a more general type than you were imagining. This causes problems:</p> <ul> <li>Perhaps you only want your function to be applicable on a smaller set of types (usually minor, but occasionally major).</li> <li>Error messages can become even more incomprehensible! (Major)</li> </ul> <h3> <a aria-hidden="true" class="anchor" href="#do-let-the-type-system-work-for-you" id="user-content-do-let-the-type-system-work-for-you"><span aria-hidden="true" class="octicon octicon-link"></span></a>Do let the type system work for you</h3> <p>Type signatures for functions are wonderful bits of documentation. It is much easier to see what's going on if you use type synonyms and signatures. Impacts:</p> <ul> <li>cleaner code</li> <li>easier for other tools to consume/reason about</li> </ul> <h3> <a aria-hidden="true" class="anchor" href="#provide-additional-types-to-aid-in-debugging" id="user-content-provide-additional-types-to-aid-in-debugging"><span aria-hidden="true" class="octicon octicon-link"></span></a>Provide additional types to aid in debugging</h3> <p>Many of the errors in coding Cryptol will be instances of type mismatching. If you can't see your problem based on the error message, try adding more type annotations. This:</p> <ul> <li>makes the interpreter do less work trying alternative possibilities and, consequently, can make error messages more comprehensible</li> <li>reduces the body of code to examine for bugs (a sort of binary bug search)</li> <li>can get you to notice where you mucked up</li> </ul> <h2> <a aria-hidden="true" class="anchor" href="#local-definitions" id="user-content-local-definitions"><span aria-hidden="true" class="octicon octicon-link"></span></a>Local Definitions</h2> <p>All the functions we've written so far have been one-liners (well, essentially). This section introduces the <code>where</code> clause, a mechanism that allows you to create local definitions in functions. There's really not too much to this, but you'll use it in almost every Cryptol function you'll ever write, so consider it important.</p> <p>Here we describe what a function looks like in Cryptol. (For the numbered identifiers here, we limit ourselves to two or three examples, but in reality there can be any number.)</p> <pre lang="comment"><code>functionName : {typeVariable0, typeVariable1} (typeConstraint0, typeConstraint1) =&gt; inputType0 -&gt; inputType1 -&gt; outputType functionName input0 input1 = output where localVariable0 = expression0 localVariable1 = expression1 output = expression2 </code></pre> <p>Here's a breakdown of how to read it:</p> <p>Function type specification:</p> <table> <thead> <tr> <th></th> <th></th> </tr> </thead> <tbody> <tr> <td><code>functionName</code></td> <td><code>:</code></td> </tr> <tr> <td>The function <code>functionName</code> </td> <td>has a type</td> </tr> </tbody> </table> <table> <thead> <tr> <th></th> </tr> </thead> <tbody> <tr> <td> <code>{</code> <code>typeVariable0</code> <code>,</code> <code>typeVariable1</code> <code>}</code> </td> </tr> <tr> <td>with type variables <code>typeVariable0</code> and <code>typeVariable1</code> </td> </tr> </tbody> </table> <table> <thead> <tr> <th></th> <th></th> </tr> </thead> <tbody> <tr> <td> <code>(</code> <code>typeConstraint0</code> <code>,</code> <code>typeConstraint1</code> <code>)</code> </td> <td><code>=&gt;</code></td> </tr> <tr> <td>and the constraints <code>typeConstraint0</code> and <code>typeConstraint1</code> </td> <td>applied to the type definition</td> </tr> </tbody> </table> <table> <thead> <tr> <th></th> <th></th> <th></th> <th></th> <th></th> </tr> </thead> <tbody> <tr> <td><code>inputType0</code></td> <td><code>-&gt;</code></td> <td><code>inputType1</code></td> <td><code>-&gt;</code></td> <td><code>outputType</code></td> </tr> <tr> <td>that takes <code>inputType0</code> </td> <td>and</td> <td><code>inputType1</code></td> <td>and returns</td> <td> <code>outputType</code>.</td> </tr> </tbody> </table> <p>Function definition:</p> <table> <thead> <tr> <th></th> <th></th> <th></th> <th></th> </tr> </thead> <tbody> <tr> <td><code>functionName</code></td> <td><code>input0</code></td> <td><code>input1</code></td> <td><code>=</code></td> </tr> <tr> <td>The function <code>functionName</code> </td> <td>takes <code>input0</code> </td> <td>and <code>input1</code> </td> <td>and returns</td> </tr> </tbody> </table> <table> <thead> <tr> <th></th> </tr> </thead> <tbody> <tr> <td><code>output</code></td> </tr> <tr> <td>the value of <code>output</code>,</td> </tr> </tbody> </table> <table> <thead> <tr> <th></th> </tr> </thead> <tbody> <tr> <td><code>where</code></td> </tr> <tr> <td>which is computed after</td> </tr> </tbody> </table> <table> <thead> <tr> <th></th> </tr> </thead> <tbody> <tr> <td> <code>localVariable0</code> <code>=</code> <code>expression0</code> </td> </tr> <tr> <td> <code>localVariable0</code> is assigned the value of <code>expression0</code>,</td> </tr> </tbody> </table> <table> <thead> <tr> <th></th> </tr> </thead> <tbody> <tr> <td> <code>localVariable1</code> <code>=</code> <code>expression1</code> </td> </tr> <tr> <td> <code>localVariable1</code> is assigned the value of <code>expression1</code>,</td> </tr> </tbody> </table> <table> <thead> <tr> <th></th> </tr> </thead> <tbody> <tr> <td> <code>output</code> <code>=</code> <code>expression2</code> </td> </tr> <tr> <td>and <code>output</code> is assigned the value of <code>expression0</code>.</td> </tr> </tbody> </table> <p>Here's an example that demonstrates the use of a <code>where</code> clause:</p> <pre lang="cryptol"><code>addMult : {n} (fin n) =&gt; [n] -&gt; [n] -&gt; [n] -&gt; [n] addMult a b c = ab + bc where ab = a INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs b bc = b INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs c </code></pre> <p>And the breakdown:</p> <table> <thead> <tr> <th></th> <th></th> <th></th> <th></th> <th></th> <th></th> <th></th> <th></th> <th></th> <th></th> <th></th> <th></th> </tr> </thead> <tbody> <tr> <td><code>addMult</code></td> <td><code>:</code></td> <td><code>{n}</code></td> <td><code>(fin n)</code></td> <td><code>=&gt;</code></td> <td><code>[n]</code></td> <td><code>-&gt;</code></td> <td><code>[n]</code></td> <td><code>-&gt;</code></td> <td><code>[n]</code></td> <td><code>-&gt;</code></td> <td><code>[n]</code></td> </tr> <tr> <td>The function <code>addmult</code> </td> <td>has a type</td> <td>with type variable <code>n</code> </td> <td>and the constraint that <code>n</code> is finite</td> <td>applied to the type definition</td> <td>that takes an <code>n</code>-bit vector</td> <td>and </td> <td>an <code>n</code>-bit vector</td> <td>and </td> <td>an <code>n</code>-bit vector</td> <td>and returns</td> <td>an <code>n</code>-bit vector.</td> </tr> </tbody> </table> <h2> <a aria-hidden="true" class="anchor" href="#properties" id="user-content-properties"><span aria-hidden="true" class="octicon octicon-link"></span></a>Properties</h2> <p>Cryptol has a built-in automated theorem proving interface. This lab doesn't go over this capability except to say that you can designate functions with an output type of <code>Bit</code> as properties using the <code>property</code> keyword. The purpose of this keyword is mostly to help document and differentiate functions that are used to compute a cryptographic algorithm, with functions that express properties about a cryptographic algorithm. For example, here we have two ways to compute the same function, and a property stating that they are equivalent for all inputs:</p> <pre lang="cryptol"><code>/** INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Checks if any of the 4 bytes of a 32 bit word are zero. Returns True INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs if any byte is zero, returns False otherwise. github-markdown-css/ html/ labs/ misc/ scripts/ specs/ anyZeroByteOpt : [32] -&gt; Bit anyZeroByteOpt v = ~((((v &amp;&amp; 0x7F7F7F7F) + 0x7F7F7F7F) || v) || 0x7F7F7F7F) != 0 anyZeroByteSpec : [32] -&gt; Bit anyZeroByteSpec bytes = b0 == 0 \/ b1 == 0 \/ b2 == 0 \/ b3 == 0 where [b0, b1, b2, b3] = split bytes : [4][8] property anyZeroByteCorrect bytes = anyZeroByteOpt bytes == anyZeroByteSpec bytes </code></pre> <p>Cryptol's <code>:prove</code> interpreter command will cue on the <code>property</code> keyword, trying to prove every <code>property</code> in scope. The <code>:prove</code> command also works if you give it a property directly, like so:</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; :prove anyZeroByteCorrect Q.E.D. (Total Elapsed Time: 0.009s, using "Z3") </code></pre> <p>Here, <code>:prove</code> tells Cryptol to call out to an external theorem prover (here, Z3) to try and prove the property. Cryptol also supports a light-weight quick check interface <code>:check</code> that runs some random inputs through a property, rather than trying to prove it for all inputs. Cryptol also allows you to <em>find</em> solutions to a property via its <code>:sat</code> command. For example,</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; :sat \x -&gt; increment x &lt; x Satisfiable (\x -&gt; increment x &lt; x) 0xffffffff = True (Total Elapsed Time: 0.009s, using "Z3") </code></pre> <p>Here we used a <em>lambda</em> function (indicated by <code>\</code>), a simple way to create a function without giving it a name. We'd read the above as, "Cryptol, find an assignment to <code>x</code> such that <code>increment x &lt; x</code>." And since the type of <code>increment</code> forces <code>x</code> to be a 32-bit bitvector, <code>increment 0xffffffff</code> overflows to zero, yielding the solution 0xffffffff.</p> <h2> <a aria-hidden="true" class="anchor" href="#operators" id="user-content-operators"><span aria-hidden="true" class="octicon octicon-link"></span></a>Operators</h2> <p>Cryptol's <code>:help</code> command will provide a brief description of an operator by issuing <code>:help</code> (<code>:h</code> for short) followed by the name of the operator in parentheses. For example:</p> <pre lang="Xcryptol"><code>Cryptol&gt; :help (@) (@) : {n, a, ix} (fin ix) =&gt; [n]a -&gt; [ix] -&gt; a Precedence 100, associates to the left. Index operator. The first argument is a sequence. The second argument is the zero-based index of the element to select from the sequence. </code></pre> <p>Many languages differentiate signed and unsigned numbers at the type level (e.g. C's <code>uint32</code> and <code>int32</code>). Cryptol has separate operators for signed operations which are indicated by a suffixed <code>$</code>. Most of the time you don't need them, as cryptography tends to use nonnegative numbers. In case you do, Cryptol also has <code>carry</code>, <code>scarry</code>, and <code>sborrow</code> operators for computing overflow and underflow of addition and subtraction.</p> <p>Where appropriate, operators act element-wise (or "blast through") typing constructs like sequences, tuples and records.</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; [[0, 1], [1, 2]] + [[3, 5], [8, 13]] [[3, 6], [9, 15]] labs::Language::Basics&gt; (3, (1, 4)) + (1, (5, 9)) (4, (6, 13)) labs::Language::Basics&gt; {x = 1, y = 3} + {y = 6, x = 10} {x = 11, y = 9} labs::Language::Basics&gt; [(0, 1), (4, 9), (16, 25)].1 [1, 9, 25] labs::Language::Basics&gt; [{x = 1, y = 3}, {y = 6, x = 10}].y [3, 6] </code></pre> <p>Following are some really quick examples of operators to remind you and show some tricks of Cryptol. Feel free to follow along by running these examples in the interpreter yourself.</p> <h3> <a aria-hidden="true" class="anchor" href="#arithmetic-------and-" id="user-content-arithmetic-------and-"><span aria-hidden="true" class="octicon octicon-link"></span></a>Arithmetic: <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code> and <code>^^</code> </h3> <h4> <a aria-hidden="true" class="anchor" href="#signed-versions--and-" id="user-content-signed-versions--and-"><span aria-hidden="true" class="octicon octicon-link"></span></a>Signed versions: <code>/$</code> and <code>%$</code> </h4> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; 1 + 1 Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for type argument 'a' of '(Cryptol::+)' 2 labs::Language::Basics&gt; 1 + 1 : [1] 0x0 labs::Language::Basics&gt; 2^^127 - 1 // a 33 digit Mersenne prime Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for type argument 'a' of '(Cryptol::^^)' 170141183460469231731687303715884105727 </code></pre> <p>The first example defaults to type <code>Integer</code>. In the second, 1-bit addition is explicitly stated so that the computation is essentially modular addition (XOR). The third shows that <code>^^</code> is exponentiation.</p> <p>The division (<code>/</code>) operation is not what a mathematician imagines in modular arithmetic. For instance <code>3 INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 3 == 1 : [3]</code> so a mathematician would expect <code>1 / 3 == 3 : [3]</code> since division is the inverse of multiplication. However, in Cryptol <code>1 / 3 == 0 : [3]</code>. Mathematically, <code>/</code> and <code>%</code> yield the quotient and remainder, respectively, in <a href="https://en.wikipedia.org/wiki/Euclidean_division" rel="nofollow">Euclidean division</a>.</p> <h3> <a aria-hidden="true" class="anchor" href="#bitwise-logical-negation--conjunction--disjunction--and-exclusive-or-" id="user-content-bitwise-logical-negation--conjunction--disjunction--and-exclusive-or-"><span aria-hidden="true" class="octicon octicon-link"></span></a>Bitwise logical: negation <code>~</code>, conjunction <code>&amp;&amp;</code>, disjunction <code>||</code> and exclusive-or <code>^</code> </h3> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; :s base=2 labs::Language::Basics&gt; ~0b000011001101 0b111100110010 labs::Language::Basics&gt; 0b111100110010 &amp;&amp; 0b100001001101 0b100000000000 labs::Language::Basics&gt; 0b000011010000 ^ 0b000000001001 0b000011011001 labs::Language::Basics&gt; 0b100000000000 || 0b000011011001 0b100011011001 </code></pre> <h3> <a aria-hidden="true" class="anchor" href="#comparison------and-" id="user-content-comparison------and-"><span aria-hidden="true" class="octicon octicon-link"></span></a>Comparison:<code>==</code>, <code>!=</code>, <code>&lt;</code> , <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code> </h3> <h4> <a aria-hidden="true" class="anchor" href="#signed-versions----and-" id="user-content-signed-versions----and-"><span aria-hidden="true" class="octicon octicon-link"></span></a>Signed versions: <code>&lt;$</code>, <code>&lt;=$</code>, <code>&gt;$</code> and <code>&gt;=$</code> </h4> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; [~1, 1] == [6 : [3], 3 INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 3] True labs::Language::Basics&gt; [~1, 1] == [6 : [4], 3 INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 3] False </code></pre> <p>In the first example, <code>6</code> is the literal value that requires the most bits and is given type <code>[3]</code>. That makes both sides of the equality test have type <code>[2][3]</code> (two elements of three bits each). Now <code>~1 : [3]</code> is <code>0b110</code> or <code>6</code> in decimal and <code>3 INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 3 : [3]</code> is <code>1 : [3]</code>, so <code>[~1, 1] == [6, 1] == [6, 3 INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 3]</code>.</p> <p>In the second example, <code>6</code> is given type <code>[4]</code>, so both sides have type <code>[2][4]</code>. Now <code>~1 : [4]</code> is <code>0b1110</code> or <code>14</code> in decimal and <code>3 INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 3 : [4]</code> is <code>9</code> in decimal. We have <code>[~1, 1] == [14, 1]</code> while <code>[6, 3 INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 3] == [6, 9]</code>, so equality fails.</p> <p><em><strong>It can be crucially important to be precise about the widths of things!</strong></em></p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; (1:[3]) &lt;$ 2 True labs::Language::Basics&gt; (1:[3]) &lt;$ -2 False labs::Language::Basics&gt; (1:[3]) &lt; -2 True labs::Language::Basics&gt; 1 &lt; -2 False labs::Language::Basics&gt; 1 &lt;$ -2 Cannot evaluate polymorphic value. Type: (Error SignedCmp Integer) =&gt; Bit </code></pre> <p>Comparisons are lexicographic on sequences of numbers.</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; [1, 2] &lt; [1, 3] True labs::Language::Basics&gt; [1, 2] &lt; [1, 2] False </code></pre> <h3> <a aria-hidden="true" class="anchor" href="#shifts-and-rotates----and-" id="user-content-shifts-and-rotates----and-"><span aria-hidden="true" class="octicon octicon-link"></span></a>Shifts and Rotates: <code>&lt;&lt;</code>, <code>&gt;&gt;</code>, <code>&lt;&lt;&lt;</code> and <code>&gt;&gt;&gt;</code> </h3> <h4> <a aria-hidden="true" class="anchor" href="#signed-version-" id="user-content-signed-version-"><span aria-hidden="true" class="octicon octicon-link"></span></a>Signed version: <code>&gt;&gt;$</code> </h4> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; :set base=16 labs::Language::Basics&gt; 0xa5a &lt;&lt; 4 0x5a0 labs::Language::Basics&gt; 0xa5a &lt;&lt; 12 0x000 labs::Language::Basics&gt; 0xa5a &lt;&lt;&lt; 16 0x5aa </code></pre> <h3> <a aria-hidden="true" class="anchor" href="#indexing-and-slicing----and-" id="user-content-indexing-and-slicing----and-"><span aria-hidden="true" class="octicon octicon-link"></span></a>Indexing and slicing: <code>@</code>, <code>!</code>, <code>@@</code> and <code>!!</code> </h3> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; :set ascii=on labs::Language::Basics&gt; "cat" @ 0 'c' labs::Language::Basics&gt; "dog" @@ [2, 1, 1, 0, 0, 1, 2] "gooddog" labs::Language::Basics&gt; "cow" ! 0 'w' </code></pre> <p>Notice that these operators all use 0-based indexing: <code>@</code> and <code>@@</code> from the beginning of the sequence and <code>!</code> and <code>!!</code> from the end.</p> <h3> <a aria-hidden="true" class="anchor" href="#concatenation-" id="user-content-concatenation-"><span aria-hidden="true" class="octicon octicon-link"></span></a>Concatenation: <code>#</code> </h3> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; "dog" # "cow" // Moof! "dogcow" </code></pre> <h3> <a aria-hidden="true" class="anchor" href="#shortcutting-logical---and-" id="user-content-shortcutting-logical---and-"><span aria-hidden="true" class="octicon octicon-link"></span></a>Shortcutting logical: <code>/\</code>, <code>\/</code> and <code>==&gt;</code> </h3> <p>These are most often used in property statements. <code>/\</code> is "and", <code>\/</code> is "or" and <code>==&gt;</code> is "implies". They have very low precedence.</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; 1 == 5 \/ 5 == 5 True labs::Language::Basics&gt; False ==&gt; 1 == 5 /\ 1 != 5 True </code></pre> <h3> <a aria-hidden="true" class="anchor" href="#if--then--else" id="user-content-if--then--else"><span aria-hidden="true" class="octicon octicon-link"></span></a><code>if ... then ... else</code> </h3> <p>Cryptol's <code>if ... then ... else</code> is much like C's ternary operator <code>?</code>...<code>:</code>. It is not like the <code>if ... then ... else</code> control structure.</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; 2 + (if 10 &lt; 7 then 12 else 4) + 2 : Integer 8 </code></pre> <p><strong>EXERCISE</strong>: Specify the Speck2n round function from page 14 of the <a href="404.pdf">Simon and Speck specification document</a>. Here we provide you with the S (rotate) functions and the inverse round function <code>R'</code>. There are also two properties that you can use to prove your work. An example of how to do this follows below.</p> <pre lang="cryptol"><code>S amount value = value &lt;&lt;&lt; amount S' amount value = value &gt;&gt;&gt; amount //Uncomment and fill in this definition according to the Speck specification: //R : // {?} // (?) =&gt; // ? R k (x, y) = undefined R' : {n} (fin n) =&gt; [n] -&gt; ([n], [n]) -&gt; ([n], [n]) R' k (x, y) = (S a ((x ^ k) - S' b (x ^ y)), S' b (x ^ y)) where n = `n : Integer a = if n == 16 then 7 else 8 : [4] b = if n == 16 then 2 else 3 : [2] RInverseProperty : {n} (fin n) =&gt; [n] -&gt; ([n], [n]) -&gt; Bit property RInverseProperty k (x, y) = R' k (R k (x, y)) == (x, y) </code></pre> <p>Here we demonstrate proving <code>RInverseProperty</code> for 32-bit inputs and 64-bit inputs. You should run the following commands after writing your specification of <code>R</code>. Cryptol will tell you when your <code>R</code> is correct by printing <code>Q.E.D.</code>. This means Cryptol has proven that your <code>R</code> is correct for all possible inputs (which is either <code>2^^96</code> for the 32-bit proof or <code>2^^192</code> for the 64-bit proof).</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; :prove RInverseProperty`{32} Q.E.D. (Total Elapsed Time: 0.008s, using "Z3") labs::Language::Basics&gt; :prove RInverseProperty`{64} Q.E.D. (Total Elapsed Time: 0.008s, using "Z3") </code></pre> <h2> <a aria-hidden="true" class="anchor" href="#common-primitives" id="user-content-common-primitives"><span aria-hidden="true" class="octicon octicon-link"></span></a>Common Primitives</h2> <p>Again, Cryptol's <code>:help</code> command will provide a brief description of the primitives in the section by issuing <code>:help</code> followed by the name of the primitive.</p> <h3> <a aria-hidden="true" class="anchor" href="#collections-of-all-false-or-all-true-bits" id="user-content-collections-of-all-false-or-all-true-bits"><span aria-hidden="true" class="octicon octicon-link"></span></a>Collections of all <code>False</code> or all <code>True</code> bits</h3> <ul> <li> <code>0</code> is a sequence of <code>False</code> bits whose type is determined by the context.</li> </ul> <pre lang="Xcryptol"><code> labs::Language::Basics&gt; 0 : [12] 0x000 </code></pre> <ul> <li> <code>zero</code> is an arbitrary collection of <code>False</code> bits whose type is determined by the context.</li> </ul> <pre lang="Xcryptol"><code> labs::Language::Basics&gt; zero : ([8], [4]) (0x00, 0x0) </code></pre> <p>Here we have produced an ordered pair of a 0 octet and a 0 nibble.</p> <ul> <li> <code>~0</code> and <code>~zero</code> produce all <code>True</code> bits correspondingly.</li> </ul> <h3> <a aria-hidden="true" class="anchor" href="#list-manipulation-take-drop-head-tail-last-and-reverse" id="user-content-list-manipulation-take-drop-head-tail-last-and-reverse"><span aria-hidden="true" class="octicon octicon-link"></span></a>List manipulation: <code>take</code>, <code>drop</code>, <code>head</code>, <code>tail</code>, <code>last</code> and <code>reverse</code> </h3> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; take "dogcow" : [3][8] "dog" labs::Language::Basics&gt; drop [2, 3, 5, 7, 11] : [3]Integer [5, 7, 11] labs::Language::Basics&gt; head [1, 2, 3] : Integer 1 labs::Language::Basics&gt; tail [0, 1, 1] : [2]Integer [1, 1] labs::Language::Basics&gt; last [2, 3, 5, 7, 11] : Integer 11 labs::Language::Basics&gt; reverse [0, 0, 1] : [3]Integer [1, 0, 0] </code></pre> <p>Of course, the sizes of lists have to be big enough for the requested operation. Also, notice that <code>head</code> (which is equivalent to <code>@0</code>) and <code>last</code> (which is equivalent to <code>!0</code>) return an element, while the others return lists.</p> <p>Often in a Cryptol program, the context will determine the shapes of sequences, so that the type annotations (<code>: [3][8]</code> and <code>: [3]Integer</code> above) will then be unnecessary.</p> <h3> <a aria-hidden="true" class="anchor" href="#list-shape-manipulation-split-groupby-join-transpose" id="user-content-list-shape-manipulation-split-groupby-join-transpose"><span aria-hidden="true" class="octicon octicon-link"></span></a>List shape manipulation: <code>split</code>, <code>groupBy</code>, <code>join</code>, <code>transpose</code> </h3> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; split`{8} 0xdeadbeef [0xd, 0xe, 0xa, 0xd, 0xb, 0xe, 0xe, 0xf] labs::Language::Basics&gt; groupBy`{4} 0xdeadbeef [0xd, 0xe, 0xa, 0xd, 0xb, 0xe, 0xe, 0xf] labs::Language::Basics&gt; join [0xca, 0xfe] 0xcafe labs::Language::Basics&gt; transpose [[1, 2], [3, 4]] Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for type of sequence member [[1, 3], [2, 4]] </code></pre> <h3> <a aria-hidden="true" class="anchor" href="#functional-programming-operators-sum-map-iterate-scanl-foldl" id="user-content-functional-programming-operators-sum-map-iterate-scanl-foldl"><span aria-hidden="true" class="octicon octicon-link"></span></a>Functional programming operators: <code>sum</code>, <code>map</code>, <code>iterate</code>, <code>scanl</code>, <code>foldl</code> </h3> <p>Cryptol supports a few common idioms in functional programming. This section briefly touches upon five of these.</p> <p>The <code>sum</code> operator takes a sequence of elements and accumulates them. Similar to other operators, <code>sum</code> acts element-wise, and as such accepts sequences of any type that arithmetic can be applied to.</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; sum [1, 2, 3, 4, 5] Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for type of sequence member 15 labs::Language::Basics&gt; sum [ [1, 2], [3, 4], [5, 6] ] Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for type of sequence member [9, 12] labs::Language::Basics&gt; sum (sum [ [1, 2], [3, 4], [5, 6] ]) Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for type of sequence member 21 </code></pre> <p>The <code>map</code> operator applies an operation to each element in a sequence.</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; :s base=10 labs::Language::Basics&gt; map increment [1, 2, 3, 4, 5] [2, 3, 4, 5, 6] labs::Language::Basics&gt; let sumt (a, b) = a + b labs::Language::Basics&gt; map sumt [ (1, 2), (3, 4), (4, 5) ] Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for type of 1st tuple field [3, 7, 9] labs::Language::Basics&gt; :s base=2 labs::Language::Basics&gt; map reverse [0b10110, 0b00101, 0b00111] [0b01101, 0b10100, 0b11100] </code></pre> <p>The <code>iterate</code> operator maps a function iteratively over an initial value, producing an infinite list of successive function applications.</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; :s base=10 labs::Language::Basics&gt; iterate increment 0 [0, 1, 2, 3, 4, ...] labs::Language::Basics&gt; let skipBy a x = x + a labs::Language::Basics&gt; iterate (skipBy 3) 0 Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for 1st type argument of '&lt;interactive&gt;::skipBy' [0, 3, 6, 9, 12, ...] </code></pre> <p>The <code>scanl</code> operator transitions an initial state given a 'next state' function and a sequence of elements to act on at each transition. <code>scanl</code> returns the sequence of initial and transitioned states. <code>foldl</code>, which you may find more useful, works just like <code>scanl</code>, but returns only the final state after all transitions. In fact, <code>foldl == last scanl</code>.</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; scanl (+) 0 [1, 2, 3, 4, 5] Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for type of sequence member [0, 1, 3, 6, 10, 15] labs::Language::Basics&gt; foldl (+) 0 [1, 2, 3, 4, 5] Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for type of sequence member 15 labs::Language::Basics&gt; let step state c = if c == True then state+1 else state-1 labs::Language::Basics&gt; scanl step 0 [True, True, False, False, True] Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for 1st type argument of '&lt;interactive&gt;::step' [0, 1, 2, 1, 0, 1] labs::Language::Basics&gt; foldl step 0 [True, True, False, False, True] Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for 1st type argument of '&lt;interactive&gt;::step' 1 labs::Language::Basics&gt; :s base=2 labs::Language::Basics&gt; scanl (&lt;&lt;) 1 [1, 2, 3, 4] : [5][12] [0b000000000001, 0b000000000010, 0b000000001000, 0b000001000000, 0b010000000000] labs::Language::Basics&gt; foldl (&lt;&lt;) 1 [1, 2, 3, 4] : [12] 0b010000000000 </code></pre> <p>In most Cryptol programs, the context will enforce the size of things, so the type annotations shown in these examples need not be present.</p> <h2> <a aria-hidden="true" class="anchor" href="#small-functions" id="user-content-small-functions"><span aria-hidden="true" class="octicon octicon-link"></span></a>Small Functions</h2> <p>Cryptol programs are just sequences of appropriate functions applied in the correct order. Good Cryptol features small, easy to understand functions composed into conceptually bigger ones. This is good computer science in general, but in Cryptol it is even more advantageous:</p> <ul> <li>Easy to test --- Cryptol's interpreter makes it very cheap to try your functions out.</li> <li>Encourages programming with properties --- Properties can be tested easily and, as we'll see, proven to provide guarantees about code. Moreover, properties serve as another kind of documentation!</li> </ul> <h2> <a aria-hidden="true" class="anchor" href="#writing-loops" id="user-content-writing-loops"><span aria-hidden="true" class="octicon octicon-link"></span></a>Writing Loops</h2> <h3> <a aria-hidden="true" class="anchor" href="#or-not" id="user-content-or-not"><span aria-hidden="true" class="octicon octicon-link"></span></a>Or not...</h3> <p>Many of Cryptol's operators naturally extend element-wise over nested sequences to any depth.</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; [[[2, 3], [5, 7]], [[11, 13], [17, 19]]] + [[[0, 1], [1, 2]], [[3, 5], [8, 13]]] Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for type of sequence member [[[2, 4], [6, 9]], [[14, 18], [25, 32]]] </code></pre> <p>So we don't have to write loops within loops to process these sorts of multidimensional arrays. All of the arithmetic, bitwise logical, and comparison operators work element-wise over nested sequences!</p> <h3> <a aria-hidden="true" class="anchor" href="#loop-indices" id="user-content-loop-indices"><span aria-hidden="true" class="octicon octicon-link"></span></a>Loop indices</h3> <p>Enumerations serve to provide the indices to loops.</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; [1..10] Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for type argument 'a' of 'Cryptol::fromTo' [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] labs::Language::Basics&gt; [1, 3..10] Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for type argument 'a' of 'Cryptol::fromThenTo' [1, 3, 5, 7, 9] </code></pre> <h4> <a aria-hidden="true" class="anchor" href="#infinite-indices" id="user-content-infinite-indices"><span aria-hidden="true" class="octicon octicon-link"></span></a>Infinite indices</h4> <p>You can have "infinite" enumerations with <code>...</code>.</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; [1...] Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for type argument 'a' of 'Cryptol::infFrom' [1, 2, 3, 4, 5, ...] </code></pre> <p>So long as only a finite prefix of any "infinite" calculation is needed we're fine.</p> <h3> <a aria-hidden="true" class="anchor" href="#loops-to-accumulate-a-value" id="user-content-loops-to-accumulate-a-value"><span aria-hidden="true" class="octicon octicon-link"></span></a>Loops to accumulate a value</h3> <p>Loops to accumulate a value are often simple calculations over indices.</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; sum [1..100] Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for type argument 'a' of 'Cryptol::fromTo' 5050 </code></pre> <h3> <a aria-hidden="true" class="anchor" href="#loops-with-functions-on-the-indices" id="user-content-loops-with-functions-on-the-indices"><span aria-hidden="true" class="octicon octicon-link"></span></a>Loops with functions on the indices</h3> <p>Loops with functions on the indices are written as <strong>sequence comprehensions</strong>. From the <a href="https://github.com/GaloisInc/cryptol/blob/master/docs/ProgrammingCryptol.pdf">Cryptol manual</a>, Section 1.6.2:</p> <blockquote> <p>A Cryptol comprehension is a way of programmatically computing the elements of a new sequence, out of the elements of existing ones. The syntax is reminiscent of the set comprehension notation from ordinary mathematics, generalized to cover parallel branches</p> </blockquote> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; [ n^^3 | n &lt;- [0..10] ] Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for type argument 'a' of 'Cryptol::fromTo' [0, 1, 8, 27, 64, 125, 216, 343, 512, 729, 1000] </code></pre> <p>Star Trek's (T.O.S.) warp factor light speed multipliers!</p> <table> <thead> <tr> <th></th> <th></th> <th></th> <th></th> <th></th> <th></th> <th></th> </tr> </thead> <tbody> <tr> <td><code>[</code></td> <td><code>n^^3</code></td> <td><code>|</code></td> <td><code>n</code></td> <td><code>&lt;-</code></td> <td><code>[0..10]</code></td> <td><code>]</code></td> </tr> <tr> <td>Generate the sequence</td> <td>with elements of the form <code>n^^3</code> </td> <td>where</td> <td><code>n</code></td> <td>draws from</td> <td>the sequence <code>0</code> through <code>10</code> </td> <td></td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> </tr> </tbody> </table> <p>We refer to the right-hand side (<code>n &lt;- [0..10]</code>) as a branch. With multiple branches, there are two choices for how the values are drawn from the branches, <em>cartesian</em> (<code>,</code> between branches), or in <em>parallel</em> (<code>|</code> between branches). For example:</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; [ (a, b) | a &lt;- [0..3] , b &lt;- [0..7] ] Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for type argument 'a' of 'Cryptol::fromTo' INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for type argument 'a' of 'Cryptol::fromTo' [(0, 0), (0, 1), (0, 2), (0, 3), (0, 4), (0, 5), (0, 6), (0, 7), (1, 0), (1, 1), (1, 2), (1, 3), (1, 4), (1, 5), (1, 6), (1, 7), (2, 0), (2, 1), (2, 2), (2, 3), (2, 4), (2, 5), (2, 6), (2, 7), (3, 0), (3, 1), (3, 2), (3, 3), (3, 4), (3, 5), (3, 6), (3, 7)] labs::Language::Basics&gt; [ (a, b) | a &lt;- [0..3] | b &lt;- [0..7] ] Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for type argument 'a' of 'Cryptol::fromTo' INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for type argument 'a' of 'Cryptol::fromTo' [(0, 0), (1, 1), (2, 2), (3, 3)] </code></pre> <p>These two types can mix, though this is not often found when specifying cryptography.</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; [ (a, b, c) | a &lt;- [0..2] , b &lt;- [3..4] | c &lt;- [5..10] ] Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for type argument 'a' of 'Cryptol::fromTo' INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for type argument 'a' of 'Cryptol::fromTo' INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for type argument 'a' of 'Cryptol::fromTo' [(0, 3, 5), (0, 4, 6), (1, 3, 7), (1, 4, 8), (2, 3, 9), (2, 4, 10)] </code></pre> <p>The previously described functional programming idioms can all be implemented using sequence comprehension. For example:</p> <ul> <li> <code>map</code> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; let sumt (a, b) = a + b labs::Language::Basics&gt; map sumt [ (1, 2), (3, 4), (4, 5) ] Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for type of 1st tuple field [3, 7, 9] labs::Language::Basics&gt; [ sumt (a, b) | (a, b) &lt;- [ (1, 2), (3, 4), (4, 5) ] ] Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for the type of '&lt;interactive&gt;::b' [3, 7, 9] </code></pre> </li> <li> <code>iterate</code> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; let skipBy a x = x + a : Integer labs::Language::Basics&gt; iterate (skipBy 3) 0 [0, 3, 6, 9, 12, ...] labs::Language::Basics&gt; let seq = [0] # [ skipBy 3 s | s &lt;- seq ] labs::Language::Basics&gt; seq [0, 3, 6, 9, 12, ...] </code></pre> </li> <li> <code>scanl</code> and <code>foldl</code> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; scanl (+) 0 [1, 2, 3, 4, 5] Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for type of sequence member [0, 1, 3, 6, 10, 15] labs::Language::Basics&gt; let seq = [0] # [ a + b | a &lt;- seq | b &lt;- [1, 2, 3, 4, 5] ] labs::Language::Basics&gt; seq Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for the type of 'b' [0, 1, 3, 6, 10, 15] labs::Language::Basics&gt; foldl (+) 0 [1, 2, 3, 4, 5] Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for type of sequence member 15 labs::Language::Basics&gt; last seq Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for 1st type argument of '&lt;interactive&gt;::seq' 15 </code></pre> </li> </ul> <h3> <a aria-hidden="true" class="anchor" href="#loops-that-modify-an-accumulator-in-place" id="user-content-loops-that-modify-an-accumulator-in-place"><span aria-hidden="true" class="octicon octicon-link"></span></a>Loops that modify an accumulator in place</h3> <p>Loops that modify an accumulator in place become self-referential sequence comprehensions. The following example illustrates this.</p> <h2> <a aria-hidden="true" class="anchor" href="#simple-block-encryption-example" id="user-content-simple-block-encryption-example"><span aria-hidden="true" class="octicon octicon-link"></span></a>Simple Block Encryption Example</h2> <pre lang="cryptol"><code>keyExpand : [32] -&gt; [10][32] keyExpand key = take roundKeys // take leverages the type signature where roundKeys : [inf][32] // a conceptually infinite list roundKeys = [key] # [ roundKey &lt;&lt;&lt; 1 | roundKey &lt;- roundKeys ] encrypt : [32] -&gt; [32] -&gt; [32] encrypt key plainText = cipherText where roundKeys = keyExpand key roundResults = [plainText] # [ roundResult ^ roundKey | roundResult &lt;- roundResults | roundKey &lt;- roundKeys ] cipherText = last roundResults </code></pre> <p>Here's an English-language breakdown of the first self-referential sequence comprehension above:</p> <table> <thead> <tr> <th></th> <th></th> <th></th> <th></th> <th></th> <th></th> <th></th> <th></th> <th></th> <th></th> <th></th> </tr> </thead> <tbody> <tr> <td><code>roundKeys</code></td> <td><code>=</code></td> <td><code>[key]</code></td> <td><code>#</code></td> <td><code>[</code></td> <td><code>roundKey &lt;&lt;&lt; 1</code></td> <td><code>|</code></td> <td><code>roundKey</code></td> <td><code>&lt;-</code></td> <td><code>roundKeys</code></td> <td><code>]</code></td> </tr> <tr> <td>The sequence <code>roundKeys</code> </td> <td>is defined as</td> <td>an initial <code>key</code> </td> <td>followed by</td> <td>the sequence</td> <td>with elements of the form <code>roundKey &lt;&lt;&lt; 1</code> </td> <td>where</td> <td><code>roundKey</code></td> <td>draws from</td> <td>the generated sequence <code>roundKeys</code> itself</td> <td></td> </tr> <tr> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> <td></td> </tr> </tbody> </table> <p>Many block ciphers are just variations of the above theme. Here's a sample of it in action:</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; encrypt 0x1337c0de 0xdabbad00 0x6157c571 labs::Language::Basics&gt; encrypt 0 0xdabbad00 0xdabbad00 </code></pre> <p>The latter shows that you can still write bad crypto with Cryptol!</p> <p>Notice that both <code>roundKeys</code> in <code>keyExpand</code> and <code>roundResults</code> in <code>encrypt</code> are self-referential sequences, a paradigm that will often occur when coding cryptography.</p> <h2> <a aria-hidden="true" class="anchor" href="#laziness" id="user-content-laziness"><span aria-hidden="true" class="octicon octicon-link"></span></a>Laziness</h2> <p>Cryptol's evaluation strategy is <a href="https://en.wikipedia.org/wiki/Lazy_evaluation" rel="nofollow">lazy</a> a.k.a. "call-by-need". I.e., computations are not performed until necessary. So</p> <pre lang="cryptol"><code>abs : [32] -&gt; [32] abs n = if n &gt;= 0 then n else -n lazyAbsMin : [32] -&gt; [32] -&gt; [32] lazyAbsMin x y = if x == 0 then 0 else min (abs x) (abs y) </code></pre> <p>Does not produce an error when <code>x</code> is zero, regardless of the value of <code>y</code>. For instance:</p> <pre lang="Xcryptol"><code>labs::Language::Basics&gt; lazyAbsMin 1 (0/0) division by 0 labs::Language::Basics&gt; lazyAbsMin 0 (0/0) 0x00000000 </code></pre> <h1> <a aria-hidden="true" class="anchor" href="#conclusion" id="user-content-conclusion"><span aria-hidden="true" class="octicon octicon-link"></span></a>Conclusion</h1> <p>Go forth and write correct cryptographic algorithms!</p> <h1> <a aria-hidden="true" class="anchor" href="#solicitation" id="user-content-solicitation"><span aria-hidden="true" class="octicon octicon-link"></span></a>Solicitation</h1> <p>How was your experience with this labs Suggestions are welcome in the form of a ticket on the course GitHub page: <a href="https://github.com/weaversa/cryptol-course/issues">https://github.com/weaversa/cryptol-course/issues</a></p> <h1> <a aria-hidden="true" class="anchor" href="#from-here-you-can-go-somewhere" id="user-content-from-here-you-can-go-somewhere"><span aria-hidden="true" class="octicon octicon-link"></span></a>From here, you can go somewhere!</h1> <table> <thead> <tr> <th align="right"></th> <th align="center"></th> <th></th> </tr> </thead> <tbody> <tr> <td align="right"></td> <td align="center"><a href="/README.html">^ Course README</a></td> <td></td> </tr> <tr> <td align="right"><a href="/labs/Interpreter/Interpreter.html">&lt; Interpreter</a></td> <td align="center"><strong>Language Basics</strong></td> <td><a href="/labs/CRC/CRC.html">CRC &gt;</a></td> </tr> <tr> <td align="right"></td> <td align="center"></td> <td></td> </tr> <tr> <td align="right"></td> <td align="center"><a href="/cryptol-style.html">+ Style Guide</a></td> <td></td> </tr> <tr> <td align="right"></td> <td align="center"><a href="/labs/Demos/Cryptol/Demos.html">+ Cryptol Demos</a></td> <td></td> </tr> <tr> <td align="right"></td> <td align="center"><a href="/labs/Demos/SAW/Demos.html">+ SAW Demos</a></td> <td></td> </tr> </tbody> </table> </article> </div> </div> </div> </div> </div> </div>
