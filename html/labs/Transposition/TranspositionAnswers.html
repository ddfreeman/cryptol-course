<?xml version='1.0' encoding='UTF-8'?> <link href="/github-markdown-css/github-css.css" rel="stylesheet"/> <meta charset="utf-8" content="text/html"/> <div class="gist"> <style class="formula-style"> svg.gh-md-to-html-formula { fill: black; } </style> <div class="gist-file"> <!-- This is the class that is responsible for the boxing! --> <div class="gist-data"> <div class="js-gist-file-update-container js-task-list-container file-box"> <div class="file" id="article-TranspositionAnswers"> <div class="Box-body readme blob js-code-block-container p-5 p-xl-6" id="file-docker-image-pull-md-readme" style="margin-left: 40px; margin-right: 40px; margin-top: 20px; margin-bottom: 20px"> <article class="markdown-body entry-content container-lg" itemprop="text"> <h1> <a aria-hidden="true" class="anchor" href="#introduction" id="user-content-introduction"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introduction</h1> <p>This library introduces and defines concepts common to transposition ciphers.</p> <h2> <a aria-hidden="true" class="anchor" href="#prerequisites" id="user-content-prerequisites"><span aria-hidden="true" class="octicon octicon-link"></span></a>Prerequisites</h2> <p>Before working through this lab, you'll need</p> <ul> <li>Cryptol to be installed and</li> <li>this module to load successfully.</li> </ul> <p>You'll also need experience with</p> <ul> <li>loading modules and evaluating functions in the interpreter and</li> <li>the <code>:prove</code> and <code>:sat</code> commands</li> <li>...</li> </ul> <h2> <a aria-hidden="true" class="anchor" href="#skills-youll-learn" id="user-content-skills-youll-learn"><span aria-hidden="true" class="octicon octicon-link"></span></a>Skills You'll Learn</h2> <p>This module will define a <em>transposition cipher</em>, in which message characters are <em>transposed</em> in a different order. Additionally, the module will recall some important cipher properties (that decryption recovers encrypted plaintext and that encryption is injective), where these operations are defined in terms of <em>permutations</em>.</p> <h2> <a aria-hidden="true" class="anchor" href="#load-this-module" id="user-content-load-this-module"><span aria-hidden="true" class="octicon octicon-link"></span></a>Load This Module</h2> <p>This lab is a <a href="https://en.wikipedia.org/wiki/Literate_programming" rel="nofollow">literate</a> Cryptol document --- that is, it can be loaded directly into the Cryptol interpreter. Load this module from within the Cryptol interpreter running in the <code>cryptol-course</code> directory with:</p> <pre lang="Xcryptol"><code>Cryptol&gt; :m labs::Transposition::TranspositionAnswers Loading module Cryptol Loading module specs::Primitive::Symmetric::Cipher::Block::Cipher Loading module specs::Primitive::Symmetric::Cipher::Block::DES Loading module labs::CryptoProofs::CryptoProofsAnswers Loading module labs::Transposition::CommonPropertiesAnswers Loading module labs::Transposition::TranspositionAnswers </code></pre> <p>We start by defining the module for this lab:</p> <pre lang="cryptol"><code>module labs::Transposition::TranspositionAnswers where </code></pre> <p>You do not need to enter the above into the interpreter; the previous <code>:m ...</code> command loaded this literate Cryptol file automatically. In general, you should run <code>Xcryptol session</code> commands in the interpreter and only change <code>cryptol</code> code as directed by the exercises, reloading for <code>:m ...</code> to import your changes.</p> <p>Additionally, we will import some common properties to apply to this spec:</p> <pre lang="cryptol"><code>import labs::Transposition::CommonPropertiesAnswers (injective, inverts) </code></pre> <h1> <a aria-hidden="true" class="anchor" href="#transposition-ciphers" id="user-content-transposition-ciphers"><span aria-hidden="true" class="octicon octicon-link"></span></a>Transposition Ciphers</h1> <p>In a <a href="https://en.wikipedia.org/wiki/Transposition_cipher" rel="nofollow"><em>transposition cipher</em></a>, messages are encrypted by <em>transposing</em> (rearranging) characters, then decrypted by inverting this rearrangement to recover the original order. Confidentiality depends upon a shared secret between a sender and receiver so that only they know how the message was transposed. A <em>permutation mapping</em>, a 1:1 mapping from the ordered set of indices <code>[0..`(m-1)]</code> to a sequence of the same indices in a different order, formalizes this transposition.</p> <p>Before moving on to simple transposition ciphers such as Scytale, Rail Fence, and Route, we first go over some basics that will be required for transposition ciphers in general.</p> <h2> <a aria-hidden="true" class="anchor" href="#permutations-and-mappings" id="user-content-permutations-and-mappings"><span aria-hidden="true" class="octicon octicon-link"></span></a>Permutations and Mappings</h2> <p>A <em>mapping</em> is an operation that associates an element of a given set (<em>domain</em>) with one or more elements of a (same or different) set (<em>range</em>). A <em>bijective</em> mapping maps each element of the domain to a distinct element of the range, and vice-versa. A transposition cipher <em>transposes</em> a message (a sequence of length <code>m</code>) to a scrambled message containing the same elements in a different order (a <em>permutation mapping</em>) known to the sender and receiver. To decrypt a message, a receiver <em>inverts</em> this permutation to yield the original message.</p> <p><strong>EXERCISE</strong>: Define a function <code>isPermutation</code> that returns whether <code>seq': [n]a</code> is a permutation of <code>seq: [n]a</code>. Check your function using <code>isPermutation_test</code>.</p> <p>(Hint: A helper function will...help.)</p> <pre lang="cryptol"><code>/** number of occurrences of `item` in `seq` github-markdown-css/ html/ labs/ misc/ scripts/ specs/ itemCount: {n, a} (fin n, Eq a) =&gt; [n]a -&gt; a -&gt; Integer itemCount seq item = counts ! 0 where counts = [ 0 ] # [ if x == item then count + 1 else count | count &lt;- counts | x &lt;- seq ] /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var is `seq'` a permutation of `seq`? github-markdown-css/ html/ labs/ misc/ scripts/ specs/ isPermutation: {n, a} (fin n, Eq a) =&gt; [n]a -&gt; [n]a -&gt; Bit isPermutation seq seq' = and [ itemCount seq x == itemCount seq' x | x &lt;- seq ] </code></pre> <pre lang="cryptol"><code>/** `isPermutation` test vectors github-markdown-css/ html/ labs/ misc/ scripts/ specs/ property isPermutation_test = and [ isPermutation "" "" , isPermutation "A" "A" , isPermutation "AA" "AA" , isPermutation "AB" "AB" , isPermutation "AB" "BA" , isPermutation "AAB" "ABA" , isPermutation "BAB" "ABB" , isPermutation "BAB" "BBA" , ~ isPermutation "A" "B" , ~ isPermutation "AA" "AB" , ~ isPermutation "AAB" "ABB" , ~ isPermutation "BAB" "AAB" ] </code></pre> <pre lang="Xcryptol"><code>labs::Transposition::TranspositionAnswers&gt; :check isPermutation_test Using exhaustive testing. Passed 1 tests. Q.E.D. </code></pre> <p><strong>EXERCISE</strong>: Define a function <code>isPermutationMapping</code>, perhaps using the built-in functions <code>all</code> and <code>elem</code>, that recognizes a permutation mapping. Check your function using <code>isPermuationMapping_test</code>.</p> <p>(Hint: <code>take`{n} [0...]</code> returns the first <code>n</code> numbers starting from <code>0</code>, i.e. the identity mapping. <code>isPermutationMapping</code> can be defined using this sequence as one of the arguments to <code>all</code>. It may be simpler to define a variant of <code>elem</code> that takes arguments in a different order.)</p> <pre lang="cryptol"><code>/** Is `pi` a permutation of `[0,n)`? github-markdown-css/ html/ labs/ misc/ scripts/ specs/ isPermutationMapping: {n, w} (fin n, Eq w, Integral w, Literal 0 w) =&gt; [n]w -&gt; Bit isPermutationMapping pi = all (elem' pi) (take`{n} [0...]) where elem' p x = elem x p /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var `isPermutationMapping` test vectors github-markdown-css/ html/ labs/ misc/ scripts/ specs/ property isPermutationMapping_test = and [ isPermutationMapping [] , isPermutationMapping [0] , isPermutationMapping [0,1] , isPermutationMapping [1,0] , isPermutationMapping [0,1,2] , isPermutationMapping [0,2,1] , isPermutationMapping [2,0,1] , ~ isPermutationMapping [1] , ~ isPermutationMapping [0,0] , ~ isPermutationMapping [0,2] , ~ isPermutationMapping [1,2] , ~ isPermutationMapping [0,1,1] , ~ isPermutationMapping [2,0,2] ] </code></pre> <pre lang="Xcryptol"><code>labs::Transposition::TranspositionAnswers&gt; :check isPermutationMapping_test Using exhaustive testing. Passed 1 tests. Q.E.D. </code></pre> <p><strong>EXERCISE</strong>: Define a function <code>permute</code> that permutes a sequence <code>seq: [n]a</code> according to a permutation mapping <code>pi: [n]w</code>.</p> <p>(Hint: Consider built-in function <code>@@</code>.)</p> <pre lang="cryptol"><code>permute: {n, a, w} Integral w =&gt; [n]w -&gt; [n]a -&gt; [n]a permute pi seq = seq @@ pi </code></pre> <p><strong>EXERCISE</strong>: Define a predicate <code>permute_permutes</code> that, given a permutation mapping <code>pi: [n]w</code> and a sequence <code>seq: [n]a</code>, <code>permute</code> returns a permutation of <code>seq</code>. Prove/check this predicate for various sequence lengths and types.</p> <pre lang="cryptol"><code>permute_permutes: {n, a, w} (fin n, Eq a, Eq w, Integral w, Literal 0 w) =&gt; [n]w -&gt; [n]a -&gt; Bit permute_permutes pi seq = isPermutationMapping pi ==&gt; isPermutation seq (permute pi seq) </code></pre> <pre lang="Xcryptol"><code>labs::Transposition::TranspositionAnswers&gt; :prove permute_permutes`{4, Char, Integer} Q.E.D. (Total Elapsed Time: 0.157s, using "Z3") labs::Transposition::TranspositionAnswers&gt; :prove permute_permutes`{6, Char, Integer} Q.E.D. (Total Elapsed Time: 22.503s, using "Z3") labs::Transposition::TranspositionAnswers&gt; :check permute_permutes`{8, [2]Char, Integer} Using random testing. Passed 100 tests. </code></pre> <p><strong>EXERCISE</strong>: Given a permutation mapping <code>pi: [n]w</code>, return its inverse <code>pi'</code> such that <code>permute pi'</code> <code>inverts</code> <code>permute pi</code>.<br/> (<code>inverts</code> is imported from <code>labs::Transposition::CommonProperties</code>.)</p> <p>(Hint: The idiomatic solution to this exercise, where <code>inverse</code> is defined with <code>take`{n} [0...]</code> as one of the arguments to <code>updates</code>, is perhaps the most elegant in all of Cryptol.)</p> <pre lang="cryptol"><code>/** return the inverse of a permutation mapping `pi` github-markdown-css/ html/ labs/ misc/ scripts/ specs/ inverse: {n, w} (fin n, Integral w, Literal 0 w) =&gt; [n]w -&gt; [n]w inverse pi = updates pi pi (take [0...]) </code></pre> <p><strong>EXERCISE</strong>: State a predicate <code>inverse_inverts</code> that <code>inverse</code> satisfies its specification above. Prove this predicate for various sequence lengths and types.</p> <pre lang="cryptol"><code>/** `inverse` inverts permutation mapping `pi` github-markdown-css/ html/ labs/ misc/ scripts/ specs/ inverse_inverts: {n, a, w} (fin n, Eq a, Eq w, Integral w, Literal 0 w) =&gt; [n]w -&gt; [n]a -&gt; Bit inverse_inverts pi seq = isPermutationMapping pi ==&gt; inverts (permute (inverse pi)) (permute pi) seq </code></pre> <pre lang="Xcryptol"><code>labs::Transposition::TranspositionAnswers&gt; :prove inverse_inverts`{4, Char, Integer} Q.E.D. (Total Elapsed Time: 0.022s, using "Z3") labs::Transposition::TranspositionAnswers&gt; :prove inverse_inverts`{8, Char, Integer} Q.E.D. (Total Elapsed Time: 3.038s, using "Z3") labs::Transposition::TranspositionAnswers&gt; :check inverse_inverts`{128, [2]Char, Integer} Using random testing. Passed 100 tests. </code></pre> <p><strong>EXERCISE</strong>: Define a predicate that <code>permute pi</code> is <code>injective</code> if <code>pi</code> is a permutation mapping, and <code>:prove</code> it for various sequence lengths and types. (<code>injective</code> is imported from <code>labs::Transposition::CommonProperties</code>.)</p> <pre lang="cryptol"><code>/** `permute pi` is `injective` if `pi` is a permutation mapping github-markdown-css/ html/ labs/ misc/ scripts/ specs/ permute_injective: {n, a, w} (fin n, Eq a, Eq w, Integral w, Literal 0 w) =&gt; [n]w -&gt; [n]a -&gt; [n]a -&gt; Bit permute_injective pi seq seq' = isPermutationMapping pi ==&gt; injective (permute pi) seq seq' </code></pre> <pre lang="Xcryptol"><code>labs::Transposition::TranspositionAnswers&gt; :prove permute_injective`{4, Char, Integer} Q.E.D. (Total Elapsed Time: 0.019s, using "Z3") labs::Transposition::TranspositionAnswers&gt; :check permute_injective`{16, Char, Integer} Using random testing. Passed 100 tests. labs::Transposition::TranspositionAnswers&gt; :check permute_injective`{128, [3]Char, Integer} Using random testing. Passed 100 tests. </code></pre> <h1> <a aria-hidden="true" class="anchor" href="#encryption-and-decryption" id="user-content-encryption-and-decryption"><span aria-hidden="true" class="octicon octicon-link"></span></a>Encryption and Decryption</h1> <p>With this foundation in place, we can define <code>encrypt</code> and <code>decrypt</code> operations for a transposition cipher in terms of a permutation mapping <code>pi</code>.</p> <p><strong>EXERCISE</strong>: Define <code>encrypt</code> and <code>decrypt</code> in terms of <code>permute</code> and a permutation mapping <code>pi</code>. Do not modify anything left of <code>=</code>.</p> <pre lang="cryptol"><code>encrypt = permute decrypt pi = permute (inverse pi) </code></pre> <p><strong>EXERCISE</strong>: Define predicates <code>cipher_recovery</code> and <code>cipher_injective</code> stating that <code>decrypt pi</code> inverts <code>encrypt pi</code> and that <code>encrypt pi</code> is injective, given a permutation mapping <code>pi</code>.<br/> (These are direct assignments to earlier predicate definitions; do not modify anything left of <code>=</code>.)</p> <pre lang="cryptol"><code>cipher_recovery = inverse_inverts cipher_injective = permute_injective </code></pre> <h1> <a aria-hidden="true" class="anchor" href="#padding-and-filtering" id="user-content-padding-and-filtering"><span aria-hidden="true" class="octicon octicon-link"></span></a>Padding and Filtering</h1> <p>Most transposition ciphers are based on an analogue to block size.<br/> For example, Scytale has a rod diameter, but not all messages wrap evenly around this rod, leaving a gap that must be managed when encrypting and decrypting an "uneven" message. Likewise, in Rail Fence, messages are split by "cycles" determined by the number of rails in the fence, and not all messages are a multiple of cycle length. One option to overcome such a limitation is to pad a message, encrypt it, send the encrypted padded message, and remove the padding characters after decryption. However, since transposition ciphers are based on message <em>indices</em> rather than <em>content</em>, the sender can simply derive a permutation mapping based on padded message length, remove indices that are out of place, and send the message permuted with this reduced mapping; the receiver can similarly derive the reduced permutation mapping, based on length, to decrypt the message.</p> <p>Removing padding characters and reducing permutation mappings are examples of the abstract problem of sequence filtering: Given a predicate <code>f: a -&gt; Bit</code>, return from a sequence <code>seq: [n]a</code> the elements <code>seq': [m]a</code> such that <code>all f seq' == True</code>.</p> <p><strong>EXERCISE</strong>: ...just kidding. Normally, we might introduce an exercise to define such a function at this point. However, in Cryptol's type system, this turns out to be a somewhat difficult problem. Indeed, this module's author, for whom all prior concepts covered in the lab came naturally, struggled for a day to arrive at what turned out to be an incorrect (but easily correctable) solution. This problem baffled all but the lead instructor for the course. Readers are invited to similarly struggle at this point, but hints showing a couple ways to solve this problem are provided below for those who instead wish to endure a diatribe on different strategies to solve this problem. Even we're not that mean!</p> <h2> <a aria-hidden="true" class="anchor" href="#index-swapping" id="user-content-index-swapping"><span aria-hidden="true" class="octicon octicon-link"></span></a>Index swapping</h2> <p>By definition, in a transposition cipher, characters of a message are rearranged. The most basic rearrangement is to swap characters at two positions (indices) in a message (sequence). However, while permutation mappings provide a more efficient mechanism to swap all characters at once, swapping turns out to be useful for the sequence filtering problem...</p> <p><strong>EXERCISE</strong>: Define a function to swap items at indices <code>i</code> and <code>j</code> of a sequence <code>seq: [n]a</code> for number <code>n</code> and arbitrary character type <code>a</code>, using <code>@</code> and <code>update</code>, then again using <code>@@</code> and <code>updates</code> (do not use a temporary variable in either definition). Use the <code>swap_equiv</code> predicate to verify that your definitions are equivalent, then the <code>swap_correct</code> predicate to show that one of them is correct.<br/> (Because they are equivalent, this will infer that the other swap function is also correct.)</p> <pre lang="cryptol"><code>/** Swap `i`th and `j`th entries of sequence `a` via `@`/`update` github-markdown-css/ html/ labs/ misc/ scripts/ specs/ swap_update: {n, a, v, w} (Integral v, Integral w) =&gt; [n]a -&gt; v -&gt; w -&gt; [n]a swap_update seq i j = update (update seq i (seq @ j)) j (seq @ i) /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var Swap `i`th and `j`th entries of sequence `a` via `@@`/`updates` github-markdown-css/ html/ labs/ misc/ scripts/ specs/ swap_updates: {n, a, w} Integral w =&gt; [n]a -&gt; w -&gt; w -&gt; [n]a swap_updates seq i j = updates seq [i,j] (seq @@ [j,i]) // Define `swap` as either of above swap functions swap = swap_updates </code></pre> <pre lang="cryptol"><code>/** `swap_update` is functionally equivalent to `swap_updates` github-markdown-css/ html/ labs/ misc/ scripts/ specs/ swap_equiv: {n, a, w} (fin n, Eq a, Cmp w, Integral w, Literal (max n n) w) =&gt; [n]a -&gt; w -&gt; w -&gt; Bit swap_equiv seq i j = 0 &lt;= i ==&gt; i &lt; `n ==&gt; 0 &lt;= j ==&gt; j &lt; `n ==&gt; swap_update`{v = w} seq i j == swap_updates seq i j /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var `swap` is correct; it just swaps values at specified indices github-markdown-css/ html/ labs/ misc/ scripts/ specs/ swap_correct: {n, a, w} (Eq a, Cmp w, Integral w, Literal (max n (max n n)) w) =&gt; [n]a -&gt; w -&gt; w -&gt; w -&gt; Bit swap_correct seq i j k = 0 &lt;= i ==&gt; i &lt; `n ==&gt; 0 &lt;= j ==&gt; j &lt; `n ==&gt; 0 &lt;= k ==&gt; k &lt; `n ==&gt; seq' @ k == if k == i then seq @ j | k == j then seq @ i else seq @ k where seq' = swap seq i j </code></pre> <pre lang="Xcryptol"><code>labs::Transposition::TranspositionAnswers&gt; :prove swap_equiv`{32, Char, Integer} Q.E.D. (Total Elapsed Time: 0.025s, using "Z3") labs::Transposition::TranspositionAnswers&gt; :prove swap_equiv`{512, Char, Integer} Q.E.D. (Total Elapsed Time: 0.304s, using "Z3") labs::Transposition::TranspositionAnswers&gt; :prove swap_equiv`{4096, Char, Integer} Q.E.D. (Total Elapsed Time: 6.001s, using "Z3") labs::Transposition::TranspositionAnswers&gt; :prove swap_correct`{32, Char, Integer} Q.E.D. (Total Elapsed Time: 0.049s, using "Z3") labs::Transposition::TranspositionAnswers&gt; :prove swap_correct`{256, Char, Integer} Q.E.D. (Total Elapsed Time: 3.686s, using "Z3") labs::Transposition::TranspositionAnswers&gt; :check swap_correct`{4096, Char, Integer} Using random testing. Passed 100 tests. Expected test coverage: 0.00% (100 of 2^^32807 values) </code></pre> <h3> <a aria-hidden="true" class="anchor" href="#swap-partitioning" id="user-content-swap-partitioning"><span aria-hidden="true" class="octicon octicon-link"></span></a>Swap-Partitioning</h3> <p>Using <code>swap</code>, we can define a function that "partitions" a sequence into a subsequence of all elements in the original sequence that satisfy a predicate, followed by a subsequence of all elements that do not. To achieve this, we can "walk" through the original sequence, and if the current character satisfies the predicate, keep walking; otherwise, swap the current character with the next one, and branch here while the subsequent character is another padding character. For this strategy, the "current" sequence and index would be captured as a sequence comprehension (much as in a block cipher's iterations of a round function).</p> <p>To better visualize this, suppose we've been given a String infused with padding characters <code>-</code>, and wish to move them to the end of the message. The following function achieves this for any message length including the empty message <code>""</code> of length <code>0</code>:</p> <pre lang="cryptol"><code>/** Shift `-` characters to the end of a `String` github-markdown-css/ html/ labs/ misc/ scripts/ specs/ rearrange: {n} (fin n) =&gt; String n -&gt; String n rearrange w = take (last out).0 where out = [(w, 0, 0)] # [ if w'@i != '-' then (w', i', j) | j &lt;= i then (w', i, i') | w'@j != '-' then (swap w' i j, i', j+1) else (w', i, j+1) where i' = zext`{width (n + 1)} i + 1 j' = zext`{width (n + 1)} j + 1 | (w', i, j) &lt;- out | _ &lt;- tail [0 .. n : [width n]] ] /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var Visualize the steps of `rearrange` github-markdown-css/ html/ labs/ misc/ scripts/ specs/ rearrange_trace: {n} (fin n) =&gt; String n -&gt; [_](String (1+n), [width (1 + n)], [width (1 + n)]) rearrange_trace w = out where out = [(w # ['-'], 0, 0)] # [ if w'@i != '-' then (w', i', j) | j &lt;= i then (w', i, i') | w'@j != '-' then (swap w' i j, i', j+1) else (w', i, j+1) where i' = zext`{width (n + 1)} i + 1 j' = zext`{width (n + 1)} j + 1 | (w', i, j) &lt;- out | _ &lt;- tail [0 .. n : [width n]] ] </code></pre> <p>Here's how this function works for the string <code>"HE-LL-O-"</code>:</p> <pre lang="Xcryptol"><code>labs::Transposition::TranspositionAnswers&gt; :s ascii=on labs::Transposition::TranspositionAnswers&gt; :s base=10 labs::Transposition::TranspositionAnswers&gt; rearrange_trace "HE-LL-O-" [("HE-LL-O--", 0, 0), ("HE-LL-O--", 1, 0), ("HE-LL-O--", 2, 0), ("HE-LL-O--", 2, 3), ("HEL-L-O--", 3, 4), ("HELL--O--", 4, 5), ("HELL--O--", 4, 6), ("HELLO----", 5, 7), ("HELLO----", 5, 8)] </code></pre> <p><strong>EXERCISE</strong>: Using <code>rearrange</code> as a blueprint, define a function <code>partition</code> that, given a predicate <code>f: a -&gt; Bit</code> and sequence <code>seq: [n]a</code>, "partitions" the sequence, returning <code>seq': [n]a</code> such that there exists some <code>i</code> such that <code>all f seqt' == True</code> and <code>all f' seqf' == True</code>, where <code>f' x = ~ f x</code> and <code>(seqt', seqf') = splitAt`{i} seq'</code>. Use the <code>partition_rearranges</code> predicate to <code>:prove</code> (or if you lose patience, <code>:check</code>) that you defined <code>partition</code> correctly, for various sequence lengths.</p> <pre lang="cryptol"><code>/** INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs "Partition" a sequence `seq` by a filtering predicate `f` such INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs that the output `seq'` has all the items satisfying `f`, followed INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs by all items not satisfying `f` github-markdown-css/ html/ labs/ misc/ scripts/ specs/ partition: {n, a} (fin n) =&gt; (a -&gt; Bit) -&gt; [n]a -&gt; [n]a partition f seq = take (last out).0 where out = ([(seq, 0, 0)] : [1]([n]a, [max 1 (width n)], [max 1 (width n)])) # [ if f (w' @ i) then (w', i', j) | j &lt;= i then (w', i, i') | f (w' @ j) then (swap w' i j, i', j') else (w', i, j') where i' = i + 1 j' = j + 1 | (w', i, j) &lt;- out | _ &lt;- tail [0 .. n : [width n]] ] </code></pre> <pre lang="cryptol"><code>/** `partition` (with arguments) is equivalent to `rearrange` github-markdown-css/ html/ labs/ misc/ scripts/ specs/ partition_rearranges: {n} (fin n) =&gt; String n -&gt; Bit partition_rearranges = partition isNotPadding === rearrange where isNotPadding c = c != '-' </code></pre> <pre lang="Xcryptol"><code>labs::Transposition::TranspositionAnswers&gt; :prove partition_rearranges`{4} Q.E.D. (Total Elapsed Time: 0.242s, using "Z3") labs::Transposition::TranspositionAnswers&gt; :prove partition_rearranges`{16} Q.E.D. (Total Elapsed Time: 4.377s, using "Z3") labs::Transposition::TranspositionAnswers&gt; :check partition_rearranges`{512} Using random testing. Passed 100 tests. Expected test coverage: 0.00% (100 of 2^^4096 values) </code></pre> <p><strong>EXERCISE</strong>: Is it possible to programmatically determine <code>i</code> for an arbitrary sequence <code>seq</code> and predicate <code>f</code>? Why (not)? Regardless, how might we be able to use <code>partition</code> for transposition ciphers?</p> <h3> <a aria-hidden="true" class="anchor" href="#rotate-partitioning" id="user-content-rotate-partitioning"><span aria-hidden="true" class="octicon octicon-link"></span></a>Rotate-Partitioning</h3> <p>Another possible approach is to walk through a sequence, rotating the remaining subsequence left iff its first element does not satisfy the filtering predicate. Visualizing this for <code>rearrange</code> on <code>"HE-LL-O-"</code>, this approach would proceed as follows:</p> <p>"HE-LL-O-" "HELL-O--" "HELLO---"</p> <p>To pull this off would require a way to enumerate over subsequences split before and after a current index, e.g.</p> <p>("", "HE-LL-O-") ("H", "E-LL-O-") ("HE", "-LL-O-") -&gt; ("HE", "LL-O--") ...</p> <p><strong>EXERCISE</strong>: Is it possible to enumerate over sequence indices and pass each index <code>i</code> to compute <code>splitAt`{i} seq</code>? Why (not)? If it is possible, feel free to submit a pull request! Otherwise, can we apply another technique to operate over these subsequences?</p> <p>Unfortunately, there is no mechanism for "type sequence comprehensions". However, we can apply recursion...</p> <pre lang="cryptol"><code>/** INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Recursively shift `-` characters to the end of a string using INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs sequence rotation github-markdown-css/ html/ labs/ misc/ scripts/ specs/ rearrange': {n} fin n =&gt; String n -&gt; String n rearrange' w = if `n == (0: [width n]) then w | w @ 0 == '-' then rearrange' (take`{max 1 n - 1} (w &lt;&lt;&lt; 1)) # (take`{min 1 n} ['-']) else (take`{min 1 n} [w @ 0]) # rearrange' (drop`{min 1 n} w) /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var The iterative and recursive `rearrange(')` functions are equivalent github-markdown-css/ html/ labs/ misc/ scripts/ specs/ rearrange_equiv: {n} fin n =&gt; String n -&gt; Bit rearrange_equiv = rearrange`{n} === rearrange'`{n} </code></pre> <pre lang="Xcryptol"><code>labs::Transposition::TranspositionAnswers&gt; :prove rearrange_equiv`{8} Q.E.D. (Total Elapsed Time: 0.477s, using "Z3") labs::Transposition::TranspositionAnswers&gt; :prove rearrange_equiv`{12} Q.E.D. (Total Elapsed Time: 10.214s, using "Z3") labs::Transposition::TranspositionAnswers&gt; :check rearrange_equiv`{128} Using random testing. Passed 100 tests. Expected test coverage: 0.00% (100 of 2^^1024 values) </code></pre> <p>In addition to being recursive, this approach requires tricks with <code>min</code> and <code>max</code> to establish type consistency for an empty sequence.<br/> What kind of fool thought this up? (See <a href="labs/Language/IntroTypeHackery.html">Intro to Type Hackery</a> for a better, more detailed example of such hackery...when this lab gets merged into the repo.)</p> <p><strong>EXERCISE</strong>: Using <code>rearrange'</code> as a blueprint, define a function <code>partition'</code> that does the same as <code>partition</code>, and try to convince yourself (via <code>:prove</code> and/or <code>:check</code> commands using <code>partition'_rearranges</code>) that your definition of <code>partition'</code> is correct for various sequence sizes and types.</p> <pre lang="cryptol"><code>partition': {n, a} fin n =&gt; (a -&gt; Bit) -&gt; [n]a -&gt; [n]a partition' f w = if `n == (0: [width n]) then w | ~ (f (w @ 0)) then partition' f (take`{max 1 n - 1} (w &lt;&lt;&lt; 1)) # (take`{min 1 n} [w @ 0]) else (take`{min 1 n} [w @ 0]) # partition' f (drop`{min 1 n} w) </code></pre> <pre lang="cryptol"><code>/** `partition'` (with arguments) is equivalent to `rearrange'` github-markdown-css/ html/ labs/ misc/ scripts/ specs/ partition'_rearranges : {n} (fin n) =&gt; String n -&gt; Bit partition'_rearranges = partition' isNotPadding === rearrange' where isNotPadding c = c != '-' </code></pre> <pre lang="Xcryptol"><code>labs::Transposition::TranspositionAnswers&gt; :prove partition'_rearranges`{8} Q.E.D. (Total Elapsed Time: 0.040s, using "Z3") labs::Transposition::TranspositionAnswers&gt; :prove partition'_rearranges`{16} Q.E.D. (Total Elapsed Time: 12.524s, using "Z3") labs::Transposition::TranspositionAnswers&gt; :check partition'_rearranges`{256} Using random testing. Passed 100 tests. Expected test coverage: 0.00% (100 of 2^^2048 values) </code></pre> <p><strong>EXERCISE</strong>: Define a property <code>partition_equiv</code> that <code>partition</code> and <code>partition'</code> are functionally equivalent. Are they? If not, why not? Can either or both still be used for transposition ciphers?</p> <pre lang="cryptol"><code>/** `partition` and `partition'` are functionally equivalent...or are they? github-markdown-css/ html/ labs/ misc/ scripts/ specs/ partition_equiv: {n, a} (fin n, Eq a) =&gt; (a -&gt; Bit) -&gt; [n]a -&gt; Bit partition_equiv f = partition`{n} f === partition'`{n} f </code></pre> <pre lang="Xcryptol"><code>labs::Transposition::TranspositionAnswers&gt; :prove partition_equiv`{8, Bit} (\b -&gt; b) Q.E.D. (Total Elapsed Time: 1.669s, using "Z3") labs::Transposition::TranspositionAnswers&gt; :prove partition_equiv`{8, [32]} (\b -&gt; b ! 0) Counterexample partition_equiv`{8, [32]} (\b -&gt; b ! 0) [0x00000000, 0x01000000, 0x00000020, 0x40000020, 0x00000040, 0x00000001, 0x00000001, 0x00000002] = False (Total Elapsed Time: 0.147s, using "Z3") </code></pre> <h2> <a aria-hidden="true" class="anchor" href="#reduction-of-padded-partition-mappings" id="user-content-reduction-of-padded-partition-mappings"><span aria-hidden="true" class="octicon octicon-link"></span></a>Reduction of Padded Partition Mappings</h2> <p>Phew! Now that we have defined a <code>partition</code> function...</p> <p><strong>EXERCISE</strong>: Define a function <code>unpad</code> that uses <code>partition</code> (or <code>partition'</code>) and <code>take</code> to reduce a permutation mapping <code>(n + p) w</code> to a possibly smaller <code>[n]w</code> (where <code>p &gt;= 0</code>). Use <code>unpad_unpads</code> to check your definition of <code>unpad</code> is correct for various <em>valid permutation mappings</em> of various lengths and paddings.<br/> (Checking invalid permutation mappings is trivial and inefficient.)<br/> Can you think of a more efficient way to increase confidence in the correctness of this function?</p> <p>(Note: <code>partition'</code> supports "larger" values of <code>n</code> and <code>p</code> for proofs, but this slows considerably for double-digit values of either. Why? Who knows?)</p> <pre lang="cryptol"><code>unpad: {n, p} (fin n, fin p) =&gt; [n + p][width (n + p)] -&gt; [n][width n] unpad pi = map drop (take (partition' ((&gt;) `n) pi)) </code></pre> <pre lang="cryptol"><code>unpad_unpads: {n, p} (fin n, fin p) =&gt; [n + p][width (n + p)] -&gt; Bit unpad_unpads pi = isPermutationMapping`{n + p} pi ==&gt; isPermutationMapping`{n} (unpad pi) </code></pre> <pre lang="Xcryptol"><code>labs::Transposition::TranspositionAnswers&gt; :prove unpad_unpads`{4, 2} Q.E.D. (Total Elapsed Time: 0.031s, using "Z3") labs::Transposition::TranspositionAnswers&gt; :prove unpad_unpads`{8, 4} Q.E.D. (Total Elapsed Time: 7.033s, using "Z3") labs::Transposition::TranspositionAnswers&gt; :check unpad_unpads`{25, 7} Using random testing. Passed 100 tests. Expected test coverage: 0.00% (100 of 2^^192 values) </code></pre> <h1> <a aria-hidden="true" class="anchor" href="#conclusion" id="user-content-conclusion"><span aria-hidden="true" class="octicon octicon-link"></span></a>Conclusion</h1> <p>This lab presented abstract definitions for transposition ciphers, formalizing definitions for permutations and inverses. Subsequent labs will provide specific examples of transposition ciphers.</p> <h1> <a aria-hidden="true" class="anchor" href="#solicitation" id="user-content-solicitation"><span aria-hidden="true" class="octicon octicon-link"></span></a>Solicitation</h1> <p>How was your experience with this labs Suggestions are welcome in the form of a ticket on the course GitHub page: <a href="https://github.com/weaversa/cryptol-course/issues">https://github.com/weaversa/cryptol-course/issues</a></p> <h1> <a aria-hidden="true" class="anchor" href="#from-here-you-can-go-somewhere" id="user-content-from-here-you-can-go-somewhere"><span aria-hidden="true" class="octicon octicon-link"></span></a>From here, you can go somewhere!</h1> <table> <thead> <tr> <th align="right"></th> <th align="center"></th> <th></th> </tr> </thead> <tbody> <tr> <td align="right"></td> <td align="center"><a href="/labs/Transposition/Contents.html">^ Transposition Ciphers</a></td> <td></td> </tr> <tr> <td align="right"><a href="/labs/Transposition/CommonProperties.html">&lt; Common Properties for Ciphers</a></td> <td align="center"><strong>Transposition (Answers)</strong></td> <td><a href="/labs/Transposition/Esrever.html">Esrever &gt;</a></td> </tr> <tr> <td align="right"></td> <td align="center"><a href="/labs/Transposition/Transposition.html">? Transposition</a></td> <td></td> </tr> </tbody> </table> </article> </div> </div> </div> </div> </div> </div>
