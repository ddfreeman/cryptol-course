<?xml version='1.0' encoding='UTF-8'?> <link href="/github-markdown-css/github-css.css" rel="stylesheet"/> <meta charset="utf-8" content="text/html"/> <div class="gist"> <style class="formula-style"> svg.gh-md-to-html-formula { fill: black; } </style> <div class="gist-file"> <!-- This is the class that is responsible for the boxing! --> <div class="gist-data"> <div class="js-gist-file-update-container js-task-list-container file-box"> <div class="file" id="article-CommonPropertiesAnswers"> <div class="Box-body readme blob js-code-block-container p-5 p-xl-6" id="file-docker-image-pull-md-readme" style="margin-left: 40px; margin-right: 40px; margin-top: 20px; margin-bottom: 20px"> <article class="markdown-body entry-content container-lg" itemprop="text"> <h1> <a aria-hidden="true" class="anchor" href="#introduction" id="user-content-introduction"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introduction</h1> <p><code>labs::CryptoProofs::CryptoProofs</code> introduced the concepts of <em>injectivity</em> and <em>inversion</em>, among others. In this lab, we build upon these concepts, introducing higher-order functions (functions that take functions as values) and specifying reusable property definitions that can be imported into other modules.</p> <h2> <a aria-hidden="true" class="anchor" href="#prerequisites" id="user-content-prerequisites"><span aria-hidden="true" class="octicon octicon-link"></span></a>Prerequisites</h2> <p>Before working through this lab, you'll need</p> <ul> <li>Cryptol to be installed,</li> <li>this module to load successfully, and</li> <li>an editor for completing the exercises in this file.</li> </ul> <p>You'll also need experience with</p> <ul> <li>loading modules and evaluating functions in the interpreter,</li> <li>sequence and <code>Integer</code> types,</li> <li>manipulating sequences using <code>#</code>, <code>take</code>, <code>split</code>, and <code>join</code>,</li> <li>writing functions and properties,</li> <li>sequence comprehensions,</li> <li>logical, comparison, and arithmetic operators,</li> <li>lambda functions, and</li> <li> <code>:prove</code> and <code>:sat</code> commands</li> </ul> <h2> <a aria-hidden="true" class="anchor" href="#skills-youll-learn" id="user-content-skills-youll-learn"><span aria-hidden="true" class="octicon octicon-link"></span></a>Skills You'll Learn</h2> <p>By the end of this lab you will be able to define higher-order functions (functions of functions) and predicates, and apply them to various cryptographic applications (e.g. decryption inverts encryption and most block ciphers are injective).</p> <h2> <a aria-hidden="true" class="anchor" href="#load-this-module" id="user-content-load-this-module"><span aria-hidden="true" class="octicon octicon-link"></span></a>Load This Module</h2> <p>This lab is a <a href="https://en.wikipedia.org/wiki/Literate_programming" rel="nofollow">literate</a> Cryptol document --- that is, it can be loaded directly into the Cryptol interpreter. Load this module from within the Cryptol interpreter running in the <code>cryptol-course</code> directory with:</p> <pre lang="Xcryptol"><code>Loading module Cryptol Cryptol&gt; :m labs::Transposition::CommonPropertiesAnswers Loading module Cryptol Loading module specs::Primitive::Symmetric::Cipher::Block::Cipher Loading module specs::Primitive::Symmetric::Cipher::Block::DES Loading module labs::CryptoProofs::CryptoProofsAnswers Loading module labs::Transposition::CommonPropertiesAnswers </code></pre> <p>The proofs in this lab require an array of different theorem provers supported by Cryptol. In order to solve them, we recommend using the Cryptol Docker container described in <a href="/INSTALL.html">INSTALL.md</a> for this course.</p> <p>The first line of a Cryptol module needs to be a module definition:</p> <pre lang="cryptol"><code>module labs::Transposition::CommonPropertiesAnswers where </code></pre> <p>You do not need to enter the above into the interpreter; the previous <code>:m ...</code> command loaded this literate Cryptol file automatically. In general, you should run <code>Xcryptol session</code> commands in the interpreter and only change <code>cryptol</code> code as directed by the exercises, reloading for <code>:m ...</code> to import your changes.</p> <p>In this lab, we'll redo exercises from <code>labs::CryptoProofs::CryptoProofs</code>, higher-order style, so we'll import the same dependency. We'll give it an alias this time so Cryptol doesn't spew warnings about shadowing its definition of <code>f</code>:</p> <pre lang="cryptol"><code>import labs::CryptoProofs::CryptoProofsAnswers (known_key, known_ct, DESFixParity) import specs::Primitive::Symmetric::Cipher::Block::DES (DES) </code></pre> <h1> <a aria-hidden="true" class="anchor" href="#higher-order-functions-functions-can-be-values" id="user-content-higher-order-functions-functions-can-be-values"><span aria-hidden="true" class="octicon octicon-link"></span></a>Higher-Order Functions: Functions can be Values!</h1> <p>Let's count to 10...</p> <pre lang="Xcryptol"><code>labs::Transposition::CommonPropertiesAnswers&gt; let _1 = 1 : Integer labs::Transposition::CommonPropertiesAnswers&gt; _1 1 labs::Transposition::CommonPropertiesAnswers&gt; 1 + it 2 labs::Transposition::CommonPropertiesAnswers&gt; 1 + it 3 labs::Transposition::CommonPropertiesAnswers&gt; 1 + it 4 labs::Transposition::CommonPropertiesAnswers&gt; 1 + it 5 labs::Transposition::CommonPropertiesAnswers&gt; 1 + it 6 labs::Transposition::CommonPropertiesAnswers&gt; 1 + it 7 labs::Transposition::CommonPropertiesAnswers&gt; 1 + it 8 labs::Transposition::CommonPropertiesAnswers&gt; 1 + it 9 labs::Transposition::CommonPropertiesAnswers&gt; 1 + it 10 </code></pre> <p>That was repetitive. Let's just ask Cryptol to count to 10:</p> <pre lang="Xcryptol"><code>labs::Transposition::CommonPropertiesAnswers&gt; take`{10} (iterate (\x -&gt; 1 + x) (1 : Integer)) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] </code></pre> <p>Adding 1 to something seems like a common task. Let's name it...</p> <pre lang="cryptol"><code>S: Integer -&gt; Integer S x = 1 + x </code></pre> <p>Peano would be proud. Wouldn't it be nice if Cryptol could just reuse <code>S</code> to repeatedly increment a counter?</p> <pre lang="Xcryptol"><code>labs::Transposition::CommonPropertiesAnswers&gt; :t \(x : Integer) -&gt; 1 + x (\(x : Integer) -&gt; 1 + x) : Integer -&gt; Integer labs::Transposition::CommonPropertiesAnswers&gt; :t S S : Integer -&gt; Integer </code></pre> <p>Wait a minute...it can!</p> <pre lang="Xcryptol"><code>labs::Transposition::CommonPropertiesAnswers&gt; take`{10} (iterate S 1) [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] </code></pre> <p>So functions can be passed around as values. Great! A function that takes a function as a value and/or returns one as a result is a <em>higher-order</em> function; a function that does not is <em>first-order</em>. But why bother?</p> <h1> <a aria-hidden="true" class="anchor" href="#five-killer-apps-silence-of-the-lambdas" id="user-content-five-killer-apps-silence-of-the-lambdas"><span aria-hidden="true" class="octicon octicon-link"></span></a>Five Killer Apps: Silence of the Lambdas</h1> <p>From <code>labs::CryptoProofs::CryptoProofs</code>:</p> <blockquote> <table> <thead> <tr> <th>Proof</th> <th>Invocation</th> </tr> </thead> <tbody> <tr> <td>Function reversal</td> <td><code>:sat \x -&gt; f x == y</code></td> </tr> <tr> <td>Proof of inversion</td> <td><code>:prove \x -&gt; g (f x) == x</code></td> </tr> <tr> <td>Proof of injectivity</td> <td><code>:prove \x y -&gt; x != y ==&gt; f x != f y</code></td> </tr> <tr> <td>Collision detection</td> <td><code>:sat \x y -&gt; f x == f y /\ x != y</code></td> </tr> <tr> <td>Equivalence checking</td> <td><code>:prove \x -&gt; f x == g x</code></td> </tr> </tbody> </table> </blockquote> <p>Lambda functions are fun, but in order to reuse them, we would need to name them. We could be silly and just assign directly to these lambda functions, filling in other parameters as necessary...</p> <table> <thead> <tr> <th>Proof</th> <th>Invocation</th> </tr> </thead> <tbody> <tr> <td>Function reversal</td> <td><code>maps_to = \f y -&gt; \x -&gt; f x == y</code></td> </tr> <tr> <td>Proof of inversion</td> <td><code>inverts = \f' f -&gt; \x -&gt; f' (f x) == x</code></td> </tr> <tr> <td>Proof of injectivity</td> <td><code>injective = \f -&gt; \x y -&gt; x != y ==&gt; f x != f y</code></td> </tr> <tr> <td>Collision detection</td> <td><code>collides = \f -&gt; \x y -&gt; f x == f y /\ x != y</code></td> </tr> <tr> <td>Equivalence checking</td> <td><code>equiv = \f f' -&gt; \x -&gt; f x == f' x</code></td> </tr> </tbody> </table> <p>...but Cryptol supports a more familiar function definition syntax, so let's use that:</p> <pre lang="cryptol"><code>/** INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs `f` maps to `y` from `x` github-markdown-css/ html/ labs/ misc/ scripts/ specs/ maps_to: {d, c} Eq c =&gt; (d -&gt; c) -&gt; c -&gt; d -&gt; Bit maps_to f y x = f x == y /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs `f'` _inverts_ `f` iff when `f` maps `x` to `f x`, INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs `f'` maps `f x` back to `x`. github-markdown-css/ html/ labs/ misc/ scripts/ specs/ inverts: {d, c} Eq d =&gt; (c -&gt; d) -&gt; (d -&gt; c) -&gt; d -&gt; Bit inverts g f x = g (f x) == x /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs `f` is _injective_ iff it maps distinct elements of its domain `d` INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs to distinct elements of its codomain `d` github-markdown-css/ html/ labs/ misc/ scripts/ specs/ injective: {d, c} (Eq d, Eq c) =&gt; (d -&gt; c) -&gt; d -&gt; d -&gt; Bit injective f x x' = x != x' ==&gt; f x != f x' /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs `x` and `x'` differ, but `f` maps them to the same value github-markdown-css/ html/ labs/ misc/ scripts/ specs/ collides: {d, c} (Eq d, Eq c) =&gt; (d -&gt; c) -&gt; d -&gt; d -&gt; Bit collides f x x' = x != x' /\ f x == f x' </code></pre> <p>Cryptol went ahead and reserved infix operator <code>===</code> to denote that functions map the same value to the same value, so <code>:prove f === f'</code> is shorthand for <code>:prove \x -&gt; f x == f' x</code>. Functional equivalence must be pretty important!</p> <h1> <a aria-hidden="true" class="anchor" href="#des-exercises-redux" id="user-content-des-exercises-redux"><span aria-hidden="true" class="octicon octicon-link"></span></a>DES Exercises, Redux</h1> <p>Because the DES exercises were so much fun last time, let's revisit them with our newfound appreciation for higher-order functions! (For exercises in this module, add your answers to empty <code>Xcryptol session</code> prompts.)</p> <p><strong>EXERCISE</strong>: Use <code>boolector</code> to reverse <code>DES.encrypt</code> for <code>known_key</code> and <code>known_ct</code> from <code>CryptoProofs</code>, using <code>maps_to</code>. (In other words, instruct the interpreter to find a plaintext such that encrypting that plaintext using DES with the <code>known_key</code> produces the <code>known_ct</code>.) Avoid lambda.</p> <pre lang="Xcryptol"><code>labs::Transposition::CommonPropertiesAnswers&gt; :s prover=boolector labs::Transposition::CommonPropertiesAnswers&gt; :sat maps_to (DES.encrypt known_key) known_ct Satisfiable maps_to (DES.encrypt known_key) known_ct 0x70617373776f7264 = True (Total Elapsed Time: 0.773s, using "Boolector") </code></pre> <p>(Hint: A curried function of two arguments can be viewed as a function of one argument to a function of one argument...)</p> <p><strong>EXERCISE</strong>: Use ABC to prove that <code>DES.encrypt</code> and <code>DES.decrypt</code> are mutual inverses for all possible <code>pt</code>, given the same <code>key</code>. Do not mention <code>pt</code> in your proof commands.</p> <pre lang="Xcryptol"><code>labs::Transposition::CommonPropertiesAnswers&gt; :s prover=abc labs::Transposition::CommonPropertiesAnswers&gt; :prove \key -&gt; inverts (DES.decrypt key) (DES.encrypt key) Q.E.D. (Total Elapsed Time: 1.080s, using "ABC") labs::Transposition::CommonPropertiesAnswers&gt; :prove \key -&gt; inverts (DES.encrypt key) (DES.decrypt key) Q.E.D. (Total Elapsed Time: 1.139s, using "ABC") </code></pre> <p><strong>EXERCISE</strong>: Use Boolector to prove that <code>DES.encrypt</code> is injective for any given <code>key</code>. Do not mention <code>pt</code>s in your proof command.<br/> Meditate on the nature of lambda and the (f)utility of names.</p> <pre lang="Xcryptol"><code>labs::Transposition::CommonPropertiesAnswers&gt; :s prover=boolector labs::Transposition::CommonPropertiesAnswers&gt; :prove \key -&gt; injective (DES.encrypt key) Q.E.D. (Total Elapsed Time: 48.986s, using "Boolector") </code></pre> <p><strong>EXERCISE</strong>: Use ABC to find two different keys and a single plaintext such that both keys encrypt that plaintext to the same ciphertext. Mention <code>key</code>s to alias <code>DES.encrypt</code> in a <code>where</code> clause, but do not mention <code>key</code> in the lambda function you pass to your command. Guess whether such a collision will be found before you observe a collision of black holes in nearby outer space.</p> <pre lang="Xcryptol"><code>labs::Transposition::CommonPropertiesAnswers&gt; :s prover=yices labs::Transposition::CommonPropertiesAnswers&gt; :sat \pt -&gt; collides (encrypt_ pt) where encrypt_ pt key = DES.encrypt key pt Satisfiable (\pt -&gt; collides (encrypt_ pt) where encrypt_ pt key = DES.encrypt key pt ) 0x0000000000000000 0x0000000000000000 0x0100000000000000 = True (Total Elapsed Time: 0.772s, using "Yices") </code></pre> <p><strong>EXERCISE</strong>: Use ABC to prove that the two keys you just found are equivalent keys; i.e., prove that keyed <code>DES.encrypt</code> and <code>DES.decrypt</code>, respectively, are equivalent for <em>all</em> <code>pt</code>/<code>ct</code>.<br/> Avoid lambda.</p> <pre lang="Xcryptol"><code>labs::Transposition::CommonPropertiesAnswers&gt; :s prover=abc labs::Transposition::CommonPropertiesAnswers&gt; let { result = _, arg1 = cx_pt, arg2 = cx_key, arg3 = cx_key_ } = it labs::Transposition::CommonPropertiesAnswers&gt; :prove (DES.encrypt cx_key) === (DES.encrypt cx_key_) Q.E.D. (Total Elapsed Time: 0.497s, using "ABC") </code></pre> <p><strong>EXERCISE</strong>: Use ABC to prove that <code>DES.encrypt key</code> is equivalent to <code>DES.encrypt (DESFixParity key)</code>. Do not mention <code>pt</code> in your proof command.</p> <pre lang="Xcryptol"><code>labs::Transposition::CommonPropertiesAnswers&gt; :s prover=abc labs::Transposition::CommonPropertiesAnswers&gt; :prove \key -&gt; DES.encrypt key === DES.encrypt (DESFixParity key) Q.E.D. (Total Elapsed Time: 0.915s, using "ABC") </code></pre> <p><strong>EXERCISE</strong>: Finally, try to find a collision with keys of distinct parity; alternatively, try to prove that no such collision exists.<br/> (This wasn't in <code>CryptoProofs</code>, but let's be extra and observe the consequences...) Feel free to go crazy with lambda. Ponder the abject hopelessness of classical crypto in a post-quantum world...</p> <pre lang="Xcryptol"><code>labs::Transposition::CommonPropertiesAnswers&gt; :s prover=any labs::Transposition::CommonPropertiesAnswers&gt; :sat \key key_ pt -&gt; DESFixParity key != DESFixParity key_ /\ DES.encrypt key pt == DES.encrypt key_ pt ... Unsatisfiable? </code></pre> <h1> <a aria-hidden="true" class="anchor" href="#conclusion" id="user-content-conclusion"><span aria-hidden="true" class="octicon octicon-link"></span></a>Conclusion</h1> <p>This lab demonstrated higher-order functions and revisited the <code>CryptoProofs</code> with named higher-order properties. Whether one chooses to use lambda notation or higher-order functions is mostly a matter of taste, though it seems useful to codify properties around which entire branches of mathematics have been studied...</p> <h1> <a aria-hidden="true" class="anchor" href="#solicitation" id="user-content-solicitation"><span aria-hidden="true" class="octicon octicon-link"></span></a>Solicitation</h1> <p>How was your experience with this labs Suggestions are welcome in the form of a ticket on the course GitHub page: <a href="https://github.com/weaversa/cryptol-course/issues">https://github.com/weaversa/cryptol-course/issues</a></p> <h1> <a aria-hidden="true" class="anchor" href="#from-here-you-can-go-somewhere" id="user-content-from-here-you-can-go-somewhere"><span aria-hidden="true" class="octicon octicon-link"></span></a>From here, you can go somewhere!</h1> <table> <thead> <tr> <th align="right"></th> <th align="center"></th> <th></th> </tr> </thead> <tbody> <tr> <td align="right"></td> <td align="center"><a href="/labs/Transposition/Contents.html">^ Transposition Ciphers</a></td> <td></td> </tr> <tr> <td align="right"></td> <td align="center"><strong>Common Properties for Ciphers</strong></td> <td><a href="/labs/Transposition/Transposition.html">Transposition &gt;</a></td> </tr> <tr> <td align="right"></td> <td align="center"><a href="/labs/Transposition/CommonProperties.html">? Common Properties for Ciphers</a></td> <td></td> </tr> </tbody> </table> </article> </div> </div> </div> </div> </div> </div>
