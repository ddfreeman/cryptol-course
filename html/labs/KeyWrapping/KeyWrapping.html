<?xml version='1.0' encoding='UTF-8'?> <link href="/github-markdown-css/github-css.css" rel="stylesheet"/> <meta charset="utf-8" content="text/html"/> <div class="gist"> <style class="formula-style"> svg.gh-md-to-html-formula { fill: black; } </style> <div class="gist-file"> <!-- This is the class that is responsible for the boxing! --> <div class="gist-data"> <div class="js-gist-file-update-container js-task-list-container file-box"> <div class="file" id="article-KeyWrapping"> <div class="Box-body readme blob js-code-block-container p-5 p-xl-6" id="file-docker-image-pull-md-readme" style="margin-left: 40px; margin-right: 40px; margin-top: 20px; margin-bottom: 20px"> <article class="markdown-body entry-content container-lg" itemprop="text"> <h1> <a aria-hidden="true" class="anchor" href="#introduction" id="user-content-introduction"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introduction</h1> <p>Key Wrapping is an important technique for storing and transmitting cryptographic keys. This module introduces a family of NIST's general purpose Key Wrapping algorithms.</p> <h2> <a aria-hidden="true" class="anchor" href="#prerequisites" id="user-content-prerequisites"><span aria-hidden="true" class="octicon octicon-link"></span></a>Prerequisites</h2> <p>Before working through this lab, you'll need</p> <ul> <li>Cryptol to be installed,</li> <li>this module to load successfully, and</li> <li>an editor for completing the exercises in this file.</li> </ul> <p>You'll also need experience with</p> <ul> <li>loading modules and evaluating functions in the interpreter,</li> <li>Cryptol's sequence and <code>Integer</code> types,</li> <li>demoting types variables to value variables,</li> <li>the <code>:prove</code> command,</li> <li>manipulating sequences using <code>#</code>, <code>take</code>, <code>drop</code>, <code>split</code>, <code>join</code>, <code>head</code>, and <code>tail</code>,</li> <li>writing functions and properties,</li> <li>sequence comprehensions,</li> <li>functions with curried parameters,</li> <li>logical, comparison, arithmetic, and conditional operators.</li> </ul> <h2> <a aria-hidden="true" class="anchor" href="#skills-you-will-learn" id="user-content-skills-you-will-learn"><span aria-hidden="true" class="octicon octicon-link"></span></a>Skills You Will Learn</h2> <p>By the end of this lab you will have read through a NIST standard and implemented a few real-world block cipher modes for authenticated encryption and decryption.</p> <p>You'll also gain experience with</p> <ul> <li>type parameters and type constraints,</li> <li>pattern matching,</li> <li>the use of pre-written cryptographic routines from other modules,</li> <li>navigating some nuances of Cryptol's type checking system, and</li> <li>the <code>foldl</code> operator.</li> </ul> <h2> <a aria-hidden="true" class="anchor" href="#load-this-module" id="user-content-load-this-module"><span aria-hidden="true" class="octicon octicon-link"></span></a>Load This Module</h2> <p>This lab is a <a href="https://en.wikipedia.org/wiki/Literate_programming" rel="nofollow">literate</a> Cryptol document --- that is, it can be loaded directly into the Cryptol interpreter. Load this module from within the Cryptol interpreter running in the <code>cryptol-course</code> directory with:</p> <pre lang="Xcryptol"><code>Loading module Cryptol Cryptol&gt; :m labs::KeyWrapping::KeyWrapping Loading module Cryptol Loading module specs::Primitive::Symmetric::Cipher::Block::AES::GF28 Loading module specs::Primitive::Symmetric::Cipher::Block::AES::State Loading module specs::Primitive::Symmetric::Cipher::Block::AES::SubBytePlain Loading module specs::Primitive::Symmetric::Cipher::Block::AES::SBox Loading module specs::Primitive::Symmetric::Cipher::Block::AES::SubByteSBox Loading module specs::Primitive::Symmetric::Cipher::Block::AES::Round Loading module specs::Primitive::Symmetric::Cipher::Block::AES::Algorithm Loading module specs::Primitive::Symmetric::Cipher::Block::AES::ExpandKey Loading module specs::Primitive::Symmetric::Cipher::Block::AES::TBox Loading module specs::Primitive::Symmetric::Cipher::Block::AES_parameterized Loading module specs::Primitive::Symmetric::Cipher::Block::Cipher Loading module specs::Primitive::Symmetric::Cipher::Block::DES Loading module specs::Primitive::Symmetric::Cipher::Block::TripleDES Loading module labs::KeyWrapping::KeyWrapping </code></pre> <p>We start by defining a new module for this lab:</p> <pre lang="cryptol"><code>module labs::KeyWrapping::KeyWrapping where </code></pre> <p>You do not need to enter the above into the interpreter; the previous <code>:m ...</code> command loaded this literate Cryptol file automatically.<br/> In general, you should run <code>Xcryptol session</code> commands in the interpreter and leave <code>cryptol</code> code alone to be parsed by <code>:m ...</code>.</p> <h1> <a aria-hidden="true" class="anchor" href="#writing-key-wrapping-routines-in-cryptol" id="user-content-writing-key-wrapping-routines-in-cryptol"><span aria-hidden="true" class="octicon octicon-link"></span></a>Writing Key Wrapping Routines in Cryptol</h1> <p>This lab takes the student through developing wrapping algorithms described in <a href="https://csrc.nist.gov/publications/detail/sp/800-38f/final" rel="nofollow">NIST Special Publication 800-38F</a> "Recommendation for Block Cipher Modes of Operation: Methods for Key Wrapping". We recommend you have this lab and the specification document open side-by-side.</p> <p>Here is the abstract from this document:</p> <blockquote> <p>This publication describes cryptographic methods that are approved for "key wrapping," i.e., the protection of the confidentiality and integrity of cryptographic keys. In addition to describing existing methods, this publication specifies two new, deterministic authenticated-encryption modes of operation of the Advanced Encryption Standard (AES) algorithm: the AES Key Wrap (KW) mode and the AES Key Wrap With Padding (KWP) mode. An analogous mode with the Triple Data Encryption Algorithm (TDEA) as the underlying block cipher, called TKW, is also specified, to support legacy applications.</p> </blockquote> <p>In this lab we will focus on developing the three main algorithms -- <code>KW</code>, <code>TKW</code>, and <code>KWP</code> -- by building up the necessary subcomponents. In fact each of these is a family of algorithms: <code>KW</code> is composed of an <em>authenticated encryption</em> component <code>KW-AE</code> and an <em>authenticated decryption</em> component <code>KW-AD</code>; similarly for <code>TKW</code> and <code>KWP</code>.</p> <h1> <a aria-hidden="true" class="anchor" href="#preliminaries" id="user-content-preliminaries"><span aria-hidden="true" class="octicon octicon-link"></span></a>Preliminaries</h1> <p>The <a href="https://www.nist.gov/itl/publications-0/nist-special-publication-800-series-general-information" rel="nofollow">NIST Special Publications 800 Series</a> provides information of interest to the computer security community. The series comprises guidelines, recommendations, technical specifications, and annual reports of NIST's cybersecurity activities.</p> <p>Reading through and implementing a formal specification in Cryptol for one of the cryptography standards in this series can be a challenge. The standards are written by a variety of authors and the algorithms are often described in one-off language-agnostic pseudo code which we have to parse. This translation process can lead to subtle implementation errors or potentially false assumptions about the algorithms which can be hard to spot.</p> <p>Our job is to extract the relevant details from the specification and build Cryptol specifications for the three main algorithms listed above.</p> <h1> <a aria-hidden="true" class="anchor" href="#getting-started" id="user-content-getting-started"><span aria-hidden="true" class="octicon octicon-link"></span></a>Getting Started</h1> <p>The Key Wrapping algorithms described in this document are a form of <a href="https://en.wikipedia.org/wiki/Block_cipher_mode_of_operation" rel="nofollow">Block Cipher Mode</a> for an existing block cipher. Section 5.1 (p. 8) of the standard indicates:</p> <blockquote> <p>For KW and KWP, the underlying block cipher shall be approved, and the block size shall be 128 bits. Currently, the AES block cipher, with key lengths of 128, 192, or 256 bits, is the only block cipher that fits this profile. For TKW, the underlying block cipher is specified to be TDEA, and the block size is therefore 64 bits; the KEK for TKW may have any length for which TDEA is approved; see [8].</p> </blockquote> <p>That is, <code>KW</code> (and <code>KWP</code>) are defined to operate with <a href="https://en.wikipedia.org/wiki/Advanced_Encryption_Standard" rel="nofollow"><code>AES</code></a> for its three key sizes: 128, 192, and 256 bits.</p> <p>The standard does not indicate a specific key size for <a href="https://en.wikipedia.org/wiki/Triple_DES" rel="nofollow"><code>TDEA</code></a>, but <code>TDEA</code>/Triple-DES is typically used with a 192-bit key and that is what we will develop later in this lab.</p> <p>Also, we will not develop <code>AES</code> or <code>TDEA</code> in this lab. Instead we will use pre-written modules which provide these block cipher primitives. The algorithms are found under the <code>specs/</code> directory in <code>specs/Primitive/Symmetric/Cipher/Block</code> and we import them into our module with the following:</p> <pre lang="cryptol"><code>import specs::Primitive::Symmetric::Cipher::Block::AES_parameterized as AES import specs::Primitive::Symmetric::Cipher::Block::TripleDES as TDEA </code></pre> <p>Cryptol modules must match the directory structure they reside in. Using descriptive names as we do here is a good way to organize related algorithms by type, function, or whatever works for your system.</p> <p>Now is a good time to scan through the specification document and get a sense of the overall organization:</p> <ul> <li> <strong>Sections 1 - 3, Purpose, Authority, and Introduction</strong> -- These sections provide background, usage, and cryptographic function of the algorithms described in this document. This information is good background if we were trying to decide <em>how</em> to use these algorithms; however we will not need to reference this information to build our specifications.</li> </ul> <p>Feel free to skim through this material or skip for now.</p> <ul> <li> <strong>Section 4, Definitions and Notation</strong> -- This section contains important definitions, acronyms, variables, and operations used in this standard. Let's scan through this to see if we find anything useful...</li> </ul> <p>Section 4.3 provides some constants <code>ICV1</code>, <code>ICV2</code>, and <code>ICV3</code> which are defined to have special values.</p> <pre lang="cryptol"><code>ICV1 = 0xA6A6A6A6A6A6A6A6 ICV2 = 0xA65959A6 ICV3 = 0xA6A6A6A6 </code></pre> <p>Section 4.4 introduces operators and notation for cryptographic functions and their building blocks. We have already imported the required block ciphers and we will be building some of these for ourselves. For the remainder, Cryptol provides analogous functionality to us in some fashion or another.</p> <p><strong>EXERCISE</strong>: Fill in definitions for the operators given in Section 4.4. Use the properties defined in Section 4.5 (also given below) to show that your answers are correct.</p> <pre lang="cryptol"><code>//0^^s -- The bit string that consists of s consecutive '0' bits. //0 : [s] /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs The integer for which the bit string X is the binary INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs representation. github-markdown-css/ html/ labs/ misc/ scripts/ specs/ int X = undefined /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs The bit length of bit string X. github-markdown-css/ html/ labs/ misc/ scripts/ specs/ len X = undefined /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs The bit string consisting of the s right-most bits INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs of the bit string X. github-markdown-css/ html/ labs/ misc/ scripts/ specs/ LSB : {s, a} (fin s, fin a, a &gt;= s) =&gt; [a] -&gt; [s] LSB X = undefined /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs The bit string consisting of the s left-most bits of INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs the bit string X. github-markdown-css/ html/ labs/ misc/ scripts/ specs/ MSB : {s, a} (fin s, a &gt;= s) =&gt; [a] -&gt; [s] MSB X = undefined // [x]s -- The binary representation of the non-negative integer // x as a string as a string of s bits, where x &lt; 2^^s. //`fromInteger` transforms an Integer into a bitvector. // The bitwise exclusive-OR of bit strings X and Y whose bit // lengths are equal. // X ^ Y // The concatenation of bit strings X and Y // X # Y </code></pre> <p>Section 4.5 contains properties of the operators given in Section 4.4.</p> <pre lang="cryptol"><code>property hexadecimalProp = 0xA659 == 0b1010011001011001 property zeroBitsProp = (0 : [8]) == 0b00000000 property concatenationProp = 0b001 # 0b10111 == 0b00110111 property XORProp = 0b10011 ^ 0b10101 == 0b00110 property lenProp = len 0b00010 == 5 property LSBProp = LSB`{3} 0b111011010 == 0b010 property MSBProp = MSB`{4} 0b111011010 == 0b1110 property bitstringProp = fromInteger 39 == 0b00100111 property intProp = int 0b00011010 == 26 </code></pre> <ul> <li> <p><strong>Section 5, Preliminaries</strong> -- This section covers usage and information about data size restrictions. The most pertinent parts are those defining what a semiblock is (which, as it turns out, is simply a 64-bit word when used in conjunction with AES, and a 32-bit word when used in conjunction with TDEA) and Table 1 that provides limits on the size of the input and outputs.</p> </li> <li> <p><strong>Section 6, Specifications of KW and KWP</strong> -- This section specifies the two families of algorithms <code>KW</code> and <code>KWP</code>. This section is the reference we will use for the bulk of this lab as we work through building a specification for <code>KW</code>.</p> </li> <li> <p><strong>Section 7, Specification of TKW</strong> -- This section specifies the final major algorithm <code>TKW</code>. It is structurally very similar to <code>KW</code>, but there are some differences that warrant its own section in the standards.</p> </li> <li> <p><strong>Section 8, Conformance</strong> -- This section has information about how implementations may claim conformance to the algorithms described in this standard.</p> </li> </ul> <h1> <a aria-hidden="true" class="anchor" href="#formal-specification-of-kw" id="user-content-formal-specification-of-kw"><span aria-hidden="true" class="octicon octicon-link"></span></a>Formal Specification of <code>KW</code> </h1> <p><code>KW</code> is a family of algorithms comprised of <code>KW-AE</code> and <code>KW-AD</code>. We start with <code>KW-AE</code>.</p> <h2> <a aria-hidden="true" class="anchor" href="#building-a-formal-specification-for-kw-ae" id="user-content-building-a-formal-specification-for-kw-ae"><span aria-hidden="true" class="octicon octicon-link"></span></a>Building a Formal Specification for <code>KW-AE</code> </h2> <p>Let's take a look at writing a specification for the <code>KW-AE</code> which is presented in <strong>Section 6</strong>. We'll call our function <code>KWAE</code> in Cryptol because we cannot use the dash/minus sign when naming functions.</p> <p>The document indicates that <code>KW-AE</code> depends on a <em>wrapping function</em> <code>W</code> (Algorithm 1, page 11). This algorithm has certain <em>prerequisites</em> which we will have to model in our formal specification:</p> <ul> <li>A <strong>Key Encryption Key (KEK)</strong> <code>K</code> and</li> <li>A <strong>designated cipher function</strong> <code>CIPHk</code>, which operates on 128-bit blocks</li> </ul> <p>The document defines a <em>semiblock</em> to be a block with half the width of the underlying block cipher, <code>CIPHk</code>. Since <code>KW-AE</code> uses <code>AES</code> as its <code>CIPHk</code>, semiblocks will be 64-bit blocks. Also notice that the specification for <code>W</code> defines the <em>Input</em> to be a string <code>S</code> of <code>n</code> semiblocks and the <em>Output</em> will be a transformed string <code>C</code> of <code>n</code> semiblocks. <em><code>W</code> was previously defined in Section 4.4 to take a bitstring, not a sequence of semiblocks</em>, so we will write <code>W</code> to consume bitstrings, but we will have to split <code>W</code> into semiblocks internally. We now have enough to build a simple type signature for <code>W</code> which will contain the following components:</p> <ul> <li> <code>n</code> -- A <em>type parameter</em> which controls the number of semiblocks in our inputs and outputs</li> <li> <code>([128] -&gt; [128])</code> -- The type of our <em>keyed</em> block cipher <code>CIPHk</code> </li> <li> <code>[n INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 64]</code> -- The type of our string of input semiblocks</li> <li> <code>[n INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 64]</code> -- The type of our transformed output</li> </ul> <p>Putting these together we have our preliminary type signature:</p> <pre lang="comment"><code>W_prelim : {n} (fin n) =&gt; ([128] -&gt; [128]) -&gt; [n INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 64] -&gt; [n INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 64] </code></pre> <p>We haven't quite captured enough about the type of <code>W</code> -- for the algorithm to operate correctly, and according to the standard, we will have to add two more constraints on <code>n</code>, namely, that <code>n &gt;= 3</code> and <code>fin n</code>.</p> <pre lang="comment"><code>W : {n} (fin n, 3 &lt;= n) =&gt; ([128] -&gt; [128]) -&gt; [n INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 64] -&gt; [n INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 64] </code></pre> <p>Taking a close look at <code>Algorithm 1</code> we can see that <code>W</code>'s step 2 transforms its inputs over a series of <code>s</code> rounds. It will make our job easier to model this step of the function first. Also, it may help to understand this step by studying <code>Figure 2</code> on page 12.</p> <p><code>WStep2</code> will inherit the same type parameters, inputs, and outputs as <code>W</code>. We add a new input <code>t</code> of type <code>Integer</code> which serves as the round counter found in step 2 of <code>Algorithm 1</code>. We also use pattern matching to pull out specific entries in the sequence of semiblocks, i.e. <code>([A, R2] # Rs)</code> gives names to the first two semiblocks of the input.</p> <p><strong>EXERCISE</strong>: Study <code>Algorithm 1</code> and <code>Figure 2</code> and implement <code>WStep2</code>.</p> <pre lang="cryptol"><code>WStep2: {n} (fin n, n &gt;= 3) =&gt; ([128] -&gt; [128]) -&gt; [n][64] -&gt; Integer -&gt; [n][64] WStep2 CIPHk ([A, R2] # Rs) t = [A'] # Rs # [Rn] where A' = undefined Rn = undefined </code></pre> <p><em>Note:</em> Pattern matching (a kind of shorthand) is used for one of the parameters to <code>WStep2</code>. According to the type signature, the second parameter is of type <code>[n][64]</code> -- a sequence of semiblocks. In the definition of <code>WStep2</code> we see that this parameter is identified as <code>([A, R2] # Rs)</code>. Cryptol assigns the <em>first</em> semiblock to <code>A</code>, the <em>second</em> semiblock to <code>R2</code>, and all the remaining semiblocks to <code>Rs</code>. Since we have the type parameter condition <code>n &gt;= 3</code> We know that there are at least three such blocks to assign, and at least one will be assigned to <code>Rs</code>.</p> <p><em>Observation</em>: It's possible that requiring <code>n &gt;= 3</code> is a mistake. We say this because (and you can test this) Cryptol also accepts the definitions of <code>W</code> and <code>WStep2</code> with type constraint <code>n &gt;= 2</code> instead of <code>n &gt;= 3</code>. In the case where <code>n == 2</code>, <code>Rs</code> is simply the empty sequence. Unfortunately, this and the use of 1-based indexing (starting <code>t</code> at <code>1</code>) causes reverberations throughout the rest of the specification, culminating in a more-complex-than-necessary <code>KWP</code> function.</p> <p>Given <code>WStep2</code>, it is a simple matter to complete the definition for <code>W</code> that we started above. But first we take a quick aside to recall the <code>foldl</code> operator which will come in very handy.</p> <p><em>But first...</em></p> <h3> <a aria-hidden="true" class="anchor" href="#a-quick-aside-on-foldl" id="user-content-a-quick-aside-on-foldl"><span aria-hidden="true" class="octicon octicon-link"></span></a>A Quick Aside on <code>foldl</code> </h3> <p><code>foldl</code> is a Cryptol Primitive and <a href="https://en.wikipedia.org/wiki/Higher-order_function" rel="nofollow">higher order function</a> which is useful for (among other things) extracting the final state from some iterative process.</p> <p>The signature for <code>foldl</code> is as follows:</p> <pre lang="Xcryptol"><code>labs::KeyWrapping::KeyWrapping&gt; :t foldl foldl : {n, a, b} (fin n) =&gt; (a -&gt; b -&gt; a) -&gt; a -&gt; [n]b -&gt; a </code></pre> <p>We see that <code>foldl</code> takes as inputs the following data</p> <ul> <li>A function of type <code>(a -&gt; b -&gt; a)</code> which transforms a "state" of type <code>a</code> into a new one by processing an element of type <code>b</code> </li> <li>An element of type <code>a</code> (an initial state value) and</li> <li>A sequence of elements of type <code>b</code> </li> </ul> <p>One application for <code>foldl</code> is to access the final element of some iterative process. For instance, we <strong>could</strong> find a list of partial sums from the sequence <code>[1..10]</code> as follows:</p> <pre lang="Xcryptol"><code>labs::KeyWrapping::KeyWrapping&gt; sums where sums = [0] # [ x + partial | x &lt;- [1..10] | partial &lt;- sums] Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for type argument 'a' of 'Cryptol::fromTo' [0, 1, 3, 6, 10, 15, 21, 28, 36, 45, 55] </code></pre> <p>However, if we are only interested in the final element of this sequence, then we can use <code>foldl</code> as follows:</p> <pre lang="Xcryptol"><code>labs::KeyWrapping::KeyWrapping&gt; foldl (+) 0 [1..10] Showing a specific instance of polymorphic result: INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs Using 'Integer' for type argument 'a' of 'Cryptol::fromTo' 55 </code></pre> <p><em>...we now return to our regularly scheduled program.</em></p> <p>We will use <code>foldl</code> along with our step function <code>WStep2</code> to write a definition for <code>W</code>.</p> <p><strong>EXERCISE</strong>: Complete the definition of <code>W</code> below by filling in the function skeleton provided.</p> <pre lang="cryptol"><code>W : {n} (fin n, 3 &lt;= n) =&gt; ([128] -&gt; [128]) -&gt; [n INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 64] -&gt; [n INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 64] W CIPHk S = join C where type s = 6 INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs (n-1) S' = split`{n} S C = foldl (WStep2 CIPHk) undefined [1..s] </code></pre> <p>With <code>W</code> in hand there it isn't much more work to complete the <code>KW-AE</code> algorithm.</p> <p><strong>EXERCISE</strong>: Study <code>Algorithm 3</code> and complete the specification for <code>KW-AE</code> by filling in the snippet below with the correct definition for <code>S</code> and <code>C</code>. Remember that <code>ICV1</code> was defined earlier in this module. Also, notice that the bounds from Table 1 (Section 5.3.1, page 10) are included as type constraints.</p> <pre lang="cryptol"><code>KWAE : {n} (fin n, 2 &lt;= n, n &lt; 2^^54) =&gt; ([128] -&gt; [128]) -&gt; [n INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 64] -&gt; [(n+1) INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 64] KWAE CIPHk P = C where S = undefined C = undefined </code></pre> <p>At this point you can check your work against six test vectors given in a property defined later on in this document. Here is the the command and sample output for <code>KWAETests</code>.</p> <pre lang="Xcryptol"><code>labs::KeyWrapping::KeyWrapping&gt; :check KWAETests Using exhaustive testing. Passed 1 tests. Q.E.D. </code></pre> <h2> <a aria-hidden="true" class="anchor" href="#building-a-formal-specification-for-kw-ad" id="user-content-building-a-formal-specification-for-kw-ad"><span aria-hidden="true" class="octicon octicon-link"></span></a>Building a Formal Specification for <code>KW-AD</code> </h2> <p>It should be fairly straightforward at this point to implement the authenticated decryption function <code>KW-AD</code> which is the other algorithm in the <code>KW</code> family. There is one significant difference, though: since the algorithm <em>authenticates</em> the decryption we will need to add an authentication check and slightly alter the type for <code>KW-AD</code>.</p> <p><strong>EXERCISE</strong>: Review <code>Algorithm 2</code> and <code>Figure 3</code> of the document and complete the definitions for the inverse routines to <code>W</code> and <code>WStep2</code> which we shall call <code>W'</code> and <code>WStep2'</code> respectively. The type declarations for these functions are provided.</p> <p><em>Hint:</em> Notice that, except for the names, the type declarations are identical. The function definitions are also very similar. Pay special attention to the order of the index variable for the main loop, the sequence of operations, and how the sequence of <code>Rs</code> transforms:</p> <pre lang="cryptol"><code>WStep2' : {n} (fin n, n &gt;= 3) =&gt; ([128] -&gt; [128]) -&gt; [n][64] -&gt; Integer -&gt; [n][64] WStep2' CIPHk' ([A] # Rs # [Rn]) t = [A', R2] # Rs where A' = undefined R2 = undefined W' : {n} (fin n, 3 &lt;= n) =&gt; ([128] -&gt; [128]) -&gt; [n INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 64] -&gt; [n INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 64] W' CIPHk' C = join S where type s = 6 INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs (n-1) C' = split`{n} C S = foldl (WStep2' CIPHk') undefined [s, s-1 .. 1] </code></pre> <p>Once you have these completed you should be able to check your work by having Cryptol <code>:prove</code> the properties <code>WStep2'Prop</code> and <code>W'Prop</code>. Your output should look something like the following:</p> <pre lang="Xcryptol"><code>labs::KeyWrapping::KeyWrapping&gt; :prove WStep2'Prop Q.E.D. (Total Elapsed Time: 0.063s, using "Z3") labs::KeyWrapping::KeyWrapping&gt; :prove W'Prop Q.E.D. (Total Elapsed Time: 0.630s, using "Z3") </code></pre> <p>These two properties state that for a fixed, dummy CIPHk and S of length 3 semiblocks, <code>WStep2</code> and <code>WStep2'</code> are inverses and <code>W</code> and <code>W'</code> are inverses. Here are the definitions of these properties:</p> <pre lang="cryptol"><code>property WStep2'Prop ARs t = WStep2'`{3} (\a -&gt; a-1) (WStep2 (\a -&gt; a+1) ARs t) t == ARs property W'Prop S = W'`{3} (\a -&gt; a-1) (W (\a -&gt; a+1) S) == S </code></pre> <p>The final step is to use these components to write the authenticated decryption algorithm <code>KW-AD</code>. Unlike <code>W'</code> and <code>WStep2'</code> this function will have a different type than its related routine in the <code>KW-AE</code> family because it needs to capture whether or not the ciphertext authenticates <em>as well as</em> computes the corresponding plaintext.</p> <p><strong>EXERCISE</strong>: Study <code>Algorithm 4</code> from the standard and complete the definition of <code>KWAD</code> below by filling in the function skeleton provided. This function needs both an appropriate definition for <code>S</code>, a computation of the authentication bit to assign to <code>FAIL</code>, and finally the appropriate plaintext.</p> <p>Notice that <code>FAIL</code> indicates a <em>failure</em> to authenticate so should be <code>False</code> for authenticated decryptions and <code>True</code> for failures to authenticate.</p> <pre lang="cryptol"><code>KWAD : {n} (fin n, 2 &lt;= n, n &lt; 2^^54) =&gt; ([128] -&gt; [128]) -&gt; [(n+1) INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 64] -&gt; (Bit, [n INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 64]) KWAD CIPHk' C = (FAIL, P) where S = undefined FAIL = undefined P = undefined </code></pre> <p>When you have successfully defined this function, you can test your work by <code>:prove</code>ing that <code>KWAE</code> and <code>KWAD</code> are inverses (well, at least for a dummy CIPHk and P of length 3 semiblocks) using the <code>KWAEInvProp</code>. You can also <code>:check</code> your work against six test vectors by using the property <code>KWADTests</code> (this is defined later on in this document).</p> <pre lang="cryptol"><code>property KWAEInvProp S = KWAD`{3} (\a -&gt; a-1) (KWAE (\a -&gt; a+1) S) == (False, S) </code></pre> <h1> <a aria-hidden="true" class="anchor" href="#formal-specifications-of-tkw-ae-and-tkw-ad" id="user-content-formal-specifications-of-tkw-ae-and-tkw-ad"><span aria-hidden="true" class="octicon octicon-link"></span></a>Formal Specifications of <code>TKW-AE</code> and <code>TKW-AD</code> </h1> <p>We're briefly skipping over the definitions of <code>KWP-AE</code> and <code>KWP-AD</code> in Section 6.3 because the definitions of <code>TWK-AE</code> and <code>TWK-AD</code> in Section 7 are very similar to <code>KW-AE</code> and <code>KW-AD</code>. We'll come back to <code>KWP</code> a little later.</p> <p><strong>EXERCISE</strong>: Try your hand at writing the specification for <code>TKW-AE</code> and <code>TKW-AD</code> from Section 7. These functions are very similar to <code>KW-AE</code> and <code>KW-AD</code> but they use the 64-bit block cipher <code>TDEA</code> (also known as <a href="https://en.wikipedia.org/wiki/Triple_DES" rel="nofollow">Triple-DES</a>). We recommend following the same steps from above and defining the helper functions <code>TWStep2</code>, <code>TWStep2'</code>, <code>TW</code>, and <code>TW'</code> before you attempt <code>TKW-AE</code> and <code>TKW-AD</code>. Test vectors are available in the <a href="kwtestvectors">kwtestvectors directory</a>.</p> <p>There are some minor modifications to be made, but things should go easily using <code>KW-AE</code> and <code>KW-AD</code> as a reference. This is a good opportunity to go back through and take a close look at the type parameters and conditions and be sure you understand what they mean and how to use them. One important thing to note is that had we defined our functions above using a <code>semigroup</code> type parameter (rather than hard-code <code>128</code> and <code>64</code>), our work defining the TKW family of functions would already be done! Consider working through the <a href="../SimonSpeck/SimonSpeck.html">Simon and Speck lab</a> next. There you'll learn how to write parameterized modules -- imagine writing a Cryptol module that takes in the semiblock size as a parameter and defines <code>W</code> and <code>W'</code>, and then importing that module with <code>semiblock = 64</code> into an AES key wrap module, and with <code>semiblock = 32</code> into a TDES key wrap module. This concept of parameterized, hierarchical modules can really help you make clear, duplication free, reusable Cryptol specifications. For those with poor imaginations, we've provided such a thing <a href="spec/">here</a>.</p> <p><strong>Back to TDES</strong>: One important difference in the TKW family is you will use the Triple-DES algorithm that's implemented in the <code>TDEA</code> module we imported earlier. You can check the type of <code>TDEA</code> in the interpreter via <code>:t TDEA::blockEncrypt</code> and <code>:t TDEA::blockDecrypt</code>. This has a slightly different interface than the block cipher we used from the <code>AES</code> module earlier. You can view how we use it here by looking at <code>TestTKWAE</code> and <code>TestTKWAD</code>. It is worth taking a quick look through the <code>TripleDES.cry</code> to learn a little bit about a particularly famous NIST test vector.</p> <p>You can test your work with the <code>TKWAETests</code> and <code>TKWADTests</code> properties. Good luck!</p> <pre lang="cryptol"><code>TWStep2: {n} (fin n, n &gt;= 3) =&gt; ([64] -&gt; [64]) -&gt; [n][32] -&gt; Integer -&gt; [n][32] TWStep2 CIPHk ([A, R2] # Rs) t = undefined TW : {n} (fin n, 3 &lt;= n) =&gt; ([64] -&gt; [64]) -&gt; [n INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 32] -&gt; [n INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 32] TW CIPHk S = undefined TKWAE : {n} (fin n, 2 &lt;= n, n &lt; 2^^28) =&gt; ([64] -&gt; [64]) -&gt; [n INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 32] -&gt; [(n+1) INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 32] TKWAE CIPHk P = undefined TWStep2' : {n} (fin n, n &gt;= 3) =&gt; ([64] -&gt; [64]) -&gt; [n][32] -&gt; Integer -&gt; [n][32] TWStep2' CIPHk' ([A] # Rs # [Rn]) t = undefined TW' : {n} (fin n, 3 &lt;= n) =&gt; ([64] -&gt; [64]) -&gt; [n INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 32] -&gt; [n INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 32] TW' CIPHk' C = undefined TKWAD : {n} (fin n, 2 &lt;= n, n &lt; 2^^28) =&gt; ([64] -&gt; [64]) -&gt; [(n+1) INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 32] -&gt; (Bit, [n INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 32]) TKWAD CIPHk' C = undefined </code></pre> <h1> <a aria-hidden="true" class="anchor" href="#a-formal-specification-of-kwp-ae" id="user-content-a-formal-specification-of-kwp-ae"><span aria-hidden="true" class="octicon octicon-link"></span></a>A Formal Specification of <code>KWP-AE</code> </h1> <p><code>KWP-AE</code> is the authenticated-encryption function and makes use of our previously defined <code>W</code>. There is a new concept to introduce with this specification.</p> <h2> <a aria-hidden="true" class="anchor" href="#oddly-typed-if-then-else-statements" id="user-content-oddly-typed-if-then-else-statements"><span aria-hidden="true" class="octicon octicon-link"></span></a>Oddly Typed <code>if-then-else</code> Statements</h2> <p>Sometimes, though not often, cryptographic algorithms will contain <code>if</code> statements where the <code>then</code> and <code>else</code> branches return different types. You were exposed to this a bit already in the <a href="../Salsa20/Salsa20.html">Salsa20 lab</a>. First off, this is always frustrating to deal with in Cryptol, and we want you to know that we feel your pain and we're sorry. Cryptol <em>can</em> handle these types of situations, but coming up with a solution requires experience with the type system that is likely only learned through trial and error.</p> <p>To dig into this a bit, let's consider the type of a generic <code>if-then-else</code> statement</p> <pre lang="Xcryptol"><code>labs::KeyWrapping::KeyWrapping&gt; :t \(c, t, e) -&gt; if c then t else e (\(c, t, e) -&gt; if c then t else e) : {a} (Bit, a, a) -&gt; a </code></pre> <p>Here we see that the condition <code>c</code> has to be of type <code>Bit</code>. This makes perfect sense given that <code>c</code> is a condition. Next, notice that the types of <code>t</code> and <code>e</code>, the values returned by the <code>then</code> and <code>else</code> cases, both have to have the same type. Here we see that Cryptol doesn't support <code>if-then-else</code> statements that return different types. So, when we see a specification that purports to do such a thing, we can either give up, or try and unify the two cases.</p> <p>Here is a silly example that closely models the behavior we'll see in <code>KWP-AE</code> and <code>KWP-AD</code>:</p> <pre lang="cryptol"><code>g : [32] -&gt; [32] g x = x + 1 h : [64] -&gt; [64] h x = x - 1 </code></pre> <pre lang="comment"><code>f : {a} (fin a, 32 &lt;= a, a &lt;= 64) =&gt; [a] -&gt; [48] f x = if `a &lt;= 0x30 then g x else h x </code></pre> <p>Here we have a function <code>f</code> that takes an <code>a</code>-bit bitvector as input where <code>a</code> is some length between <code>32</code> and <code>64</code> bits. <code>f</code> always returns <code>48</code> bits. Here's the strange part --- if <code>a &lt;= 0x30</code> (<code>0x30</code> is <code>48</code>), <code>f</code> returns <code>g x</code>, where <code>g</code> takes and returns only 32-bit values. If <code>a &gt; 0x30</code>, <code>f</code> returns <code>h x</code> where <code>h</code> takes and returns only 64-bit values. If we try to load this function into Cryptol we see:</p> <pre lang="Xcryptol"><code>[error] at labs/KeyWrapping/KeyWrapping.md:863:1--866:14: Failed to validate user-specified signature. in the definition of 'f', at labs/KeyWrapping/KeyWrapping.md:863:1--863:2, we need to show that for any type a assuming • fin a • 32 &lt;= a • a &lt;= 64 the following constraints hold: • a == 64 arising from matching types at labs/KeyWrapping/KeyWrapping.md:866:13--866:14 • a == 32 arising from matching types at labs/KeyWrapping/KeyWrapping.md:864:13--864:14 [error] at labs/KeyWrapping/KeyWrapping.md:864:11--864:12: Type mismatch: Expected type: 48 Inferred type: 32 [error] at labs/KeyWrapping/KeyWrapping.md:866:11--866:12: Type mismatch: Expected type: 48 Inferred type: 64 </code></pre> <p>This message tells us that <code>a</code>, the length of our input, has to simultaneously be both <code>64</code> and <code>32</code> and (looking at the line numbers) that these constraints come from the types of <code>g</code> and <code>h</code>.</p> <p>In support of fixing the function, notice that since <code>g</code> always takes and returns 32-bit values, we have to shrink <code>x</code> from <code>a</code> bits to <code>32</code> bits, and widen the result up to <code>48</code> bits. And, since <code>h</code> always takes and returns 64-bit values, we have to widen <code>x</code> from <code>a</code> bits to <code>64</code> bits, and shrink the result back down to <code>48</code> bits. To help us do this resizing work, we'll introduce <code>shrink</code> and <code>widen</code> functions.</p> <pre lang="cryptol"><code>widen : {a, b} (fin a, fin b) =&gt; [b] -&gt; [a + b] widen a = 0 # a shrink : {a, b} (fin a, fin b) =&gt; [a + b] -&gt; [b] shrink a = drop a </code></pre> <p><code>widen</code> takes any sized input and prepends <code>0</code> or more <code>False</code> bits. <code>shrink</code> takes any sized input and removes <code>0</code> or more bits from the front. Using these two functions, we can fix our <code>f</code> from above:</p> <pre lang="cryptol"><code>f : {a} (32 &lt;= a, a &lt;= 64) =&gt; [a] -&gt; [48] f x = if `a &lt;= 0x30 then widen (g (shrink x)) else shrink (h (widen x)) </code></pre> <p>And here we test that <code>f</code> correctly calls <code>g</code> and <code>h</code> (which increment and decrement by 1, respectively).</p> <pre lang="Xcryptol"><code>labs::KeyWrapping::KeyWrapping&gt; f (10 : [37]) 0x00000000000b labs::KeyWrapping::KeyWrapping&gt; f (10 : [53]) 0x000000000009 </code></pre> <h2> <a aria-hidden="true" class="anchor" href="#kwp-ae-top-level-function" id="user-content-kwp-ae-top-level-function"><span aria-hidden="true" class="octicon octicon-link"></span></a>KWP-AE Top Level Function</h2> <p>With that consideration firmly under our belt, we can now tackle <code>KWP-AE</code>.</p> <p><strong>EXERCISE</strong>: Study <code>Algorithm 5</code> from the standard and complete the definition of <code>KWPAE</code> below by filling in the function skeleton provided with appropriate logic. Use the <code>shrink</code> and <code>widen</code> functions to assist in resizing <code>S</code> and the outputs of <code>W</code> and <code>CIPHk</code> on the <code>then</code> and <code>else</code> branches of line 5.</p> <p><em>Hint:</em> You'll notice that we needed to pull in the type variable <code>n</code> and the type constraints from <code>W</code>, as well as to relate <code>n</code> and <code>k</code> (the types of <code>S</code> and <code>C</code>). You'll need to pass <code>n</code> into <code>W</code>, ensuring that we avoid the <code>n == 2</code> case. This can be done by calling <code>W</code> like so <code>W`{max 3 n}</code>. Also, remember that <code>ICV2</code> was defined above, so we do not need to redefine it inside <code>KWPAE</code>.</p> <pre lang="cryptol"><code>KWPAE : {k, n} // k is [len(P)/8], Algorithm 5 ( 1 &lt;= k, k &lt; 2^^32 // Bounds on the number of octets of P, from Table 1 , 2 &lt;= n, n == 1 + k /^ 8) =&gt; // Here we relate n and k ([128] -&gt; [128]) -&gt; [k INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 8] -&gt; [n INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 64] KWPAE CIPHk P = C where type padlen = 0 PAD = undefined : [8 INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs padlen] S = undefined : [n INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 64] C = if len P &lt;= 64 then undefined else undefined </code></pre> <p>Feel free to use the provided <code>KWPAETests</code> property to check your work.</p> <p>Here we point out our observation from earlier -- if the type constraint on <code>n</code> in <code>W</code> had been <code>n &gt;= 2</code> and had <code>t</code> started at <code>0</code> rather than <code>1</code>, then <code>W CIPHk S == CIPHK S</code> and we wouldn't have needed to test on the length of <code>P</code>. The definition of <code>C</code> would then have been <code>C = W'{n} CIPHk S</code>. So, hopefully you see how an arbitrary (mistaken?) constraint (compounded by 1-based indexing) percolated through this specification and caused trouble.</p> <h1> <a aria-hidden="true" class="anchor" href="#a-formal-specification-of-kwp-ad" id="user-content-a-formal-specification-of-kwp-ad"><span aria-hidden="true" class="octicon octicon-link"></span></a>A Formal Specification of <code>KWP-AD</code> </h1> <p><code>KWP-AD</code> is the authenticated-decryption function and makes use of our previously defined <code>W'</code>.</p> <p><strong>EXERCISE</strong>: Study <code>Algorithm 6</code> from the standard and complete the definition of <code>KWPAD</code> below by filling in the function skeleton provided with appropriate logic. You'll notice we've used types and pattern matching to separate out the 4 components of S, rather than ask you to muck about defining <code>Plen</code>, <code>padlen</code>, <code>LSB...</code>, etc. In truth, it's not possible to follow the spec verbatim here because <code>Plen</code> is derived from a value variable (<code>S</code>) but later used to derive a type variable (<code>padlen</code> on line 6 which is then used as the size of <code>0</code> on line 8), and promotion of value variables to a type variables is explicitly forbidden in Cryptol.</p> <pre lang="cryptol"><code>KWPAD : {k, n} // k is [len(P)/8], Algorithm 5 ( 1 &lt;= k, k &lt; 2^^32 // Bounds on the number of octets of P, from Table 1 , 2 &lt;= n, n == 1 + k /^ 8) =&gt; // Here we relate n and k ([128] -&gt; [128]) -&gt; [n INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 64] -&gt; (Bit, [k INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 8]) KWPAD CIPHk' C = (FAIL, P) where S = if `n == 2 then undefined else undefined Plen : [32] PAD : [k*8 %^ 64] ICV2' # Plen # P # PAD = S FAIL = ICV2' != ICV2 \/ Plen != (fromInteger (len P / 8) : [32]) \/ PAD != 0 </code></pre> <p>Feel free to use the provided <code>KWPADTests</code> property to check your work.</p> <h2> <a aria-hidden="true" class="anchor" href="#but-what-about-the-ciphertext-limits" id="user-content-but-what-about-the-ciphertext-limits"><span aria-hidden="true" class="octicon octicon-link"></span></a>But what about the ciphertext limits?</h2> <p>I'm sure the sticklers in the class noticed that we reused the same type constraints from <code>KWP-AE</code> which don't overtly mention the ciphertext bounds from Table 1, namely, that the length of <code>C</code> must be between <code>2</code> and <code>2^^29</code>, inclusively. Fortunately, those bounds <em>should</em> be inferred by the plaintext bounds. And, now that you mention it, we can check! Table 1 tells us that, for <code>KWP</code>, if the number of octets of <code>P</code> is the upper limit of <code>2^^32-1</code>, that the number of semiblocks of <code>C</code> should be <code>2^^29</code>.</p> <p>Asking Cryptol for the type of <code>KWPAE</code> after plugging in <code>2^^32-1</code> for <code>k</code> gives an <code>l</code> of <code>34359738432</code>:</p> <pre lang="Xcryptol"><code>labs::KeyWrapping::KeyWrappingAnswers&gt; :t KWPAE`{k = 2^^32 - 1} KWPAE`{k = 2 ^^ 32 - 1} : ([128] -&gt; [128]) -&gt; [34359738360] -&gt; [34359738432] </code></pre> <p>Well, what's <code>34359738432</code>? Is it <code>2^^29</code> 64-bit words? Let's first check how many 64-bit words it is. Here's one way:</p> <pre lang="Xcryptol"><code>labs::KeyWrapping::KeyWrappingAnswers&gt; :t \(a : [34359738432]) -&gt; groupBy`{64} a (\(a : [34359738432]) -&gt; groupBy`{64} a) : [34359738432] -&gt; [536870913][64] </code></pre> <p>Great...now what's <code>536870913</code>? Is it <code>2^^29</code>?</p> <pre lang="Xcryptol"><code>labs::KeyWrapping::KeyWrappingAnswers&gt; 2^^29 : Integer 536870912 </code></pre> <p>Woh! Its not. <code>536870913</code> is <code>2^^29 + 1</code>. Let's double check this --- here is a command that tests the <code>2^^29</code> upper bound from Table 1:</p> <pre lang="Xcryptol"><code>labs::KeyWrapping::KeyWrappingAnswers&gt; :t KWPAE`{k = 2^^32 - 1, n = (2^^29)} [error] at &lt;interactive&gt;:1:1--1:6: Unsolvable constraints: • 536870912 == 536870913 arising from use of expression KWPAE at &lt;interactive&gt;:1:1--1:6 • Reason: It is not the case that 536870912 == 536870913 </code></pre> <p>And here is a command that tests the bound we just found, <code>2^^29 + 1</code>.</p> <pre lang="Xcryptol"><code>labs::KeyWrapping::KeyWrappingAnswers&gt; :t KWPAE`{k = 2^^32 - 1, n = (2^^29 + 1)} KWPAE`{k = 2 ^^ 32 - 1, n = (2 ^^ 29 + 1)} : ([128] -&gt; [128]) -&gt; [34359738360] -&gt; [34359738432] </code></pre> <p>Well folks, it appears we (...well, Cryptol) just found a bug (albeit a small one) in one of NIST's most well read crypto specs. Thanks sticklers!</p> <h1> <a aria-hidden="true" class="anchor" href="#test-vectors" id="user-content-test-vectors"><span aria-hidden="true" class="octicon octicon-link"></span></a>Test Vectors</h1> <p>Test vectors were not included in NIST-SP-800-38F; however, the <code>KW-AE</code>, <code>KW-AD</code> family of key-wrapping algorithm enjoy common usage and are described and referenced in other standards material. The test vectors in this section were drawn from <a href="https://tools.ietf.org/html/rfc3394" rel="nofollow">RFC 3394</a>.</p> <p>Recall that you can check individual properties with the <code>:check</code> command in the interpreter. Here are some test vectors from <a href="rfc3394.pdf">RFC 3394</a> that are useful for testing <code>KW-AE</code> and <code>KW-AD</code>.</p> <pre lang="cryptol"><code>TestKWAE : {a, n} (a &gt;= 2, 4 &gt;= a, n &gt;= 2, 2^^54-1 &gt;= n) =&gt; [a*64] -&gt; [n*64] -&gt; [(n+1)*64] TestKWAE k pt = ct where ct = KWAE (\p -&gt; AES::encrypt k p) pt property KWAETests = (TestKWAE (join [ 0x0001020304050607, 0x08090A0B0C0D0E0F ]) (join [ 0x0011223344556677, 0x8899AABBCCDDEEFF ]) == join [ 0x1fa68b0a8112b447, 0xaef34bd8fb5a7b82, 0x9d3e862371d2cfe5 ]) /\ (TestKWAE (join [ 0x0001020304050607, 0x08090A0B0C0D0E0F, 0x1011121314151617 ]) (join [ 0x0011223344556677, 0x8899AABBCCDDEEFF ]) == join [ 0x96778b25ae6ca435, 0xf92b5b97c050aed2, 0x468ab8a17ad84e5d ]) /\ (TestKWAE (join [ 0x0001020304050607, 0x08090A0B0C0D0E0F, 0x1011121314151617, 0x18191A1B1C1D1E1F ]) (join [ 0x0011223344556677, 0x8899AABBCCDDEEFF ]) == join [ 0x64e8c3f9ce0f5ba2, 0x63e9777905818a2a, 0x93c8191e7d6e8ae7 ]) </code></pre> <pre lang="cryptol"><code>TestKWAD : {a, n} (a &gt;= 2, 4 &gt;= a, n &gt;= 2, 2^^54-1 &gt;= n) =&gt; [a*64] -&gt; [(n+1)*64] -&gt; (Bit, [n*64]) TestKWAD k ct = (FAIL, pt) where (FAIL, pt) = KWAD (\c -&gt; AES::decrypt k c) ct property KWADTests = (TestKWAD (join [ 0x0001020304050607, 0x08090A0B0C0D0E0F ]) (join [ 0x1fa68b0a8112b447, 0xaef34bd8fb5a7b82, 0x9d3e862371d2cfe5 ]) == (False, join [ 0x0011223344556677, 0x8899AABBCCDDEEFF ])) /\ (TestKWAD (join [ 0x0001020304050607, 0x08090A0B0C0D0E0F, 0x1011121314151617 ]) (join [ 0x96778b25ae6ca435, 0xf92b5b97c050aed2, 0x468ab8a17ad84e5d ]) == (False, join [ 0x0011223344556677, 0x8899AABBCCDDEEFF ])) /\ (TestKWAD (join [ 0x0001020304050607, 0x08090A0B0C0D0E0F, 0x1011121314151617, 0x18191A1B1C1D1E1F ]) (join [ 0x64e8c3f9ce0f5ba2, 0x63e9777905818a2a, 0x93c8191e7d6e8ae7 ]) == (False, join [ 0x0011223344556677, 0x8899AABBCCDDEEFF ])) /\ (TestKWAD (join [ 0x0001020304050607, 0x08090A0B0C0D0E0F, 0x1011121314151617, 0x18191A1B1C1D1E10 ]) (join [ 0x28c9f404c4b810f4, 0xcbccb35cfb87f826, 0x3f5786e2d80ed326, 0xcbc7f0e71a99f43b, 0xfb988b9b7a02dd21 ]) == (True, join [ 0x20ca3cba6f93747e, 0x456c666158ed83da, 0x3a6d614e94ba1ac5, 0xfe957c5963100091])) </code></pre> <pre lang="cryptol"><code>TestTKWAE : {n} (n &gt;= 2, 2^^28-1 &gt;= n) =&gt; [192] -&gt; [n*32] -&gt; [(n+1)*32] TestTKWAE (k0#k1#k2) pt = ct where ct = TKWAE (\p -&gt; TDEA::blockEncrypt (k0, k1, k2, p)) pt property TKWAETests = (TestTKWAE 0x12b84c663120c196f8fc17428bc86a110d92cc7c4d3cb695 0xef7da3da918d0679 == 0x7a72bbca3aa323aa1ac231ba) </code></pre> <pre lang="cryptol"><code>TestTKWAD : {n} (n &gt;= 2, 2^^28-1 &gt;= n) =&gt; [192] -&gt; [(n+1)*32] -&gt; (Bit, [n*32]) TestTKWAD (k0#k1#k2) pt = (FAIL, ct) where (FAIL, ct) = TKWAD (\p -&gt; TDEA::blockDecrypt (k0, k1, k2, p)) pt property TKWADTests = (TestTKWAD 0xe273cd9d7210a973b4113c5772474938d353b54e265dd944 0x10a38310b604b48f94357d67 == (False, 0x2ffd56320f1dff99)) /\ ((TestTKWAD 0x8476d056582e322d93ab9919086798ba48d03eddf77803e5 0x2c9bf0131cf486402422b8ef).0 == True) </code></pre> <pre lang="cryptol"><code>TestKWPAE : {a, k, n} ( a &gt;= 2, 4 &gt;= a , 1 &lt;= k, k &lt; 2^^32 , 2 &lt;= n, n == 1 + k /^ 8 ) =&gt; [a*64] -&gt; [k][8] -&gt; [n INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 64] TestKWPAE k pt = ct where ct = KWPAE`{k, n} (\p -&gt; AES::encrypt k p) (join pt) property KWPAETests = (TestKWPAE 0x6decf10a1caf8e3b80c7a4be8c9c84e8 [0x49] == 0x01a7d657fc4a5b216f261cca4d052c2b) TestKWPAD : {a, k, n} ( a &gt;= 2, 4 &gt;= a , 1 &lt;= k, k &lt; 2^^32 , 2 &lt;= n, n == 1 + k /^ 8 ) =&gt; [a*64] -&gt; [n INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs 64] -&gt; (Bit, [k][8]) TestKWPAD k ct = (FAIL, split pt) where (FAIL, pt) = KWPAD`{k, n} (\c -&gt; AES::decrypt k c) ct property KWPADTests = (TestKWPAD 0x49319c331231cd6bf74c2f70b07fcc5c 0x9c211f32f8b341f32b052fed5f31a387 == (False, [0xe4])) /\ ((TestKWPAD`{k=1} 0x30be7ff51227f0eef786cb7be2482510 0x7f61a0a8b2fe7803f2947d233ec3a255).0 == True) /\ (TestKWPAD 0x58e7c85b60c7675002bd66e290d20cc694279f0bfc766840 0xf2edd87dabb4a6ae568662f20fcc4770 == (False, [0x76])) /\ ((TestKWPAD`{k=1} 0x94c8dae772a43b5e00468e0947699b239dfe30ab5f90e2f6 0x239c6bceee3583fe7825011e02f01cc0).0 == True) </code></pre> <h1> <a aria-hidden="true" class="anchor" href="#references" id="user-content-references"><span aria-hidden="true" class="octicon octicon-link"></span></a>References</h1> <ul> <li> <p><a href="https://csrc.nist.gov/publications/detail/sp/800-38f/final" rel="nofollow">NIST Special Publication 800-38F</a> -- "Recommendation for Block Cipher Modes of Operation: Methods for Key Wrapping". This document is the primary source material for this lab. It contains the original specifications from NIST that we develop in this lesson.</p> </li> <li> <p><a href="https://tools.ietf.org/html/rfc3394" rel="nofollow">RFC 3394</a> -- "Advanced Encryption Standard (AES) Key Wrap Algorithm". This RFC contains information on the same set of algorithms and includes test vectors which we use in this lab to verify that our algorithms were implemented correctly.</p> </li> </ul> <h1> <a aria-hidden="true" class="anchor" href="#solicitation" id="user-content-solicitation"><span aria-hidden="true" class="octicon octicon-link"></span></a>Solicitation</h1> <p>How was your experience with this labs Suggestions are welcome in the form of a ticket on the course GitHub page: <a href="https://github.com/weaversa/cryptol-course/issues">https://github.com/weaversa/cryptol-course/issues</a></p> <h1> <a aria-hidden="true" class="anchor" href="#from-here-you-can-go-somewhere" id="user-content-from-here-you-can-go-somewhere"><span aria-hidden="true" class="octicon octicon-link"></span></a>From here, you can go somewhere!</h1> <table> <thead> <tr> <th align="right"></th> <th align="center"></th> <th></th> </tr> </thead> <tbody> <tr> <td align="right"></td> <td align="center"><a href="/README.html">^ Course README</a></td> <td></td> </tr> <tr> <td align="right"><a href="/labs/CryptoProofs/CryptoProofs.html">&lt; Cryptographic Properties</a></td> <td align="center"><strong>Key Wrapping</strong></td> <td><a href="/labs/LoremIpsum/LoremIpsum.html">Capstone &gt;</a></td> </tr> <tr> <td align="right"></td> <td align="center"><a href="/labs/KeyWrapping/KeyWrappingAnswers.html">! Key Wrapping (Answers)</a></td> <td></td> </tr> <tr> <td align="right"></td> <td align="center"></td> <td></td> </tr> <tr> <td align="right"></td> <td align="center"><a href="/labs/SimonSpeck/SimonSpeck.html">+ Parameterized Modules</a></td> <td></td> </tr> </tbody> </table> </article> </div> </div> </div> </div> </div> </div>
