<?xml version='1.0' encoding='UTF-8'?> <link href="/github-markdown-css/github-css.css" rel="stylesheet"/> <meta charset="utf-8" content="text/html"/> <div class="gist"> <style class="formula-style"> svg.gh-md-to-html-formula { fill: black; } </style> <div class="gist-file"> <!-- This is the class that is responsible for the boxing! --> <div class="gist-data"> <div class="js-gist-file-update-container js-task-list-container file-box"> <div class="file" id="article-Caesar"> <div class="Box-body readme blob js-code-block-container p-5 p-xl-6" id="file-docker-image-pull-md-readme" style="margin-left: 40px; margin-right: 40px; margin-top: 20px; margin-bottom: 20px"> <article class="markdown-body entry-content container-lg" itemprop="text"> <h1> <a aria-hidden="true" class="anchor" href="#introduction" id="user-content-introduction"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introduction</h1> <p>This demo gives an overview of the famous Caesar cipher.</p> <h2> <a aria-hidden="true" class="anchor" href="#prerequisites" id="user-content-prerequisites"><span aria-hidden="true" class="octicon octicon-link"></span></a>Prerequisites</h2> <p>Before working through this lab, you'll need</p> <ul> <li>Cryptol to be installed and</li> <li>this module to load successfully.</li> </ul> <p>You'll also need experience with</p> <ul> <li>loading modules and evaluating functions in the interpreter and</li> <li>the <code>:prove</code> and <code>:sat</code> commands.</li> </ul> <h2> <a aria-hidden="true" class="anchor" href="#skills-youll-learn" id="user-content-skills-youll-learn"><span aria-hidden="true" class="octicon octicon-link"></span></a>Skills You'll Learn</h2> <p>By the end of this demo you'll understand a bit more about the Cryptol language and how to use the interpreter to prove properties or find bugs in Cryptol specifications.</p> <h2> <a aria-hidden="true" class="anchor" href="#load-this-module" id="user-content-load-this-module"><span aria-hidden="true" class="octicon octicon-link"></span></a>Load This Module</h2> <p>This lab is a <a href="https://en.wikipedia.org/wiki/Literate_programming" rel="nofollow">literate</a> Cryptol document --- that is, it can be loaded directly into the Cryptol interpreter. Load this module from within the Cryptol interpreter running in the <code>cryptol-course</code> directory with:</p> <pre lang="Xcryptol"><code>Loading module Cryptol Cryptol&gt; :m labs::Demos::Cryptol::Caesar Loading module Cryptol Loading module labs::Demos::Cryptol::Caesar </code></pre> <p>The Cryptol module starts by defining a new module for this lab:</p> <pre lang="cryptol"><code>module labs::Demos::Cryptol::Caesar where </code></pre> <p>You do not need to enter the above into the interpreter; the previous <code>:m ...</code> command loaded this literate Cryptol file automatically.<br/> In general, you should run <code>Xcryptol session</code> commands in the interpreter and leave <code>cryptol</code> code alone to be parsed by <code>:m ...</code>.</p> <h1> <a aria-hidden="true" class="anchor" href="#caesar-cipher" id="user-content-caesar-cipher"><span aria-hidden="true" class="octicon octicon-link"></span></a>Caesar Cipher</h1> <p>The <a href="https://en.wikipedia.org/wiki/Caesar_cipher" rel="nofollow">Caesar cipher</a> is a simple shift cipher named after Julius Caesar. This cipher was... evidently effective against illiterate adversaries of ancient Rome, but will it protect its secrets from you and Cryptol...?</p> <p>A Caesar cipher simply rotates characters in the alphabet by a fixed amount. (Caesar himself used a left rotation by 3, according to Suetonius.) We could define this simply and directly in Cryptol:</p> <pre lang="cryptol"><code>caesar msg = map rot3 msg where rot3 c = if 'A' &lt;= c /\ c &lt;= 'Z' then (['A'..'Z':Char] &gt;&gt;&gt; 3) @ (c - 'A') else c </code></pre> <pre lang="Xcryptol"><code>labs::Demos::Cryptol::Caesar&gt; :s prover=abc labs::Demos::Cryptol::Caesar&gt; :s ascii=on labs::Demos::Cryptol::Caesar&gt; caesar "ATTACK AT DAWN" "XQQXZH XQ AXTK" </code></pre> <p>...and that's it! Thank you for trying the Caesar demo...</p> <p>...</p> <h2> <a aria-hidden="true" class="anchor" href="#generalization" id="user-content-generalization"><span aria-hidden="true" class="octicon octicon-link"></span></a>Generalization</h2> <p>OK, we can explore this a little further. Let's generalize it:</p> <pre lang="cryptol"><code>/** number of characters in alphabet github-markdown-css/ html/ labs/ misc/ scripts/ specs/ type w = 26 /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var an alphabet of characters included in a rotation cipher github-markdown-css/ html/ labs/ misc/ scripts/ specs/ type Alphabet = String w /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var a left-rotation amount github-markdown-css/ html/ labs/ misc/ scripts/ specs/ type Key = [width w] /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var alphabet of characters to "encrypt" github-markdown-css/ html/ labs/ misc/ scripts/ specs/ alphabet = ['A'..'Z'] : Alphabet </code></pre> <h2> <a aria-hidden="true" class="anchor" href="#aside-a-confounding-search" id="user-content-aside-a-confounding-search"><span aria-hidden="true" class="octicon octicon-link"></span></a>Aside: A confounding search</h2> <p>The above definition assumed a contiguous character set, which does not necessarily hold in general. So we'll need a function to find a character in the alphabet:</p> <pre lang="cryptol"><code>/** INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs index (from end) of first occurrence (from start) of item `x` in INSTALL.md LICENSE README.md cryptol-style.md github-markdown-css html index.html labs misc scripts specs sequence `L` github-markdown-css/ html/ labs/ misc/ scripts/ specs/ index: {n, a} (fin n, Eq a) =&gt; [n]a -&gt; a -&gt; [1 + n] index L x = if (or M) then (lg2 ((0b0 # M) + 1) - 1) else (length M) where M = (map ((==) x) L) </code></pre> <p>It's...not obvious how this function works, so let's establish a property to verify its correctness:</p> <pre lang="cryptol"><code>/** `index` is correct for any sequence github-markdown-css/ html/ labs/ misc/ scripts/ specs/ indexCorrect: {n, a} (fin n, Eq a) =&gt; [n]a -&gt; a -&gt; Bit indexCorrect L x = elem x L ==&gt; L ! (index L x) == x /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var index is correctly identified for all characters in alphabet github-markdown-css/ html/ labs/ misc/ scripts/ specs/ charIsAtIndex : Char -&gt; Bit property charIsAtIndex = indexCorrect alphabet </code></pre> <pre lang="Xcryptol"><code>labs::Demos::Cryptol::Caesar&gt; :prove charIsAtIndex Q.E.D. (Total Elapsed Time: 0.072s, using "ABC") </code></pre> <p>The property even holds for other sequences, repeating or not:</p> <pre lang="Xcryptol"><code>labs::Demos::Cryptol::Caesar&gt; :prove \(A : [64]Char) -&gt; indexCorrect A Q.E.D. (Total Elapsed Time: 1.172s, using "ABC") labs::Demos::Cryptol::Caesar&gt; :prove \(L : [33][32]) -&gt; indexCorrect L Q.E.D. (Total Elapsed Time: 0.347s, using "ABC") </code></pre> <p>But to work for a Caesar cipher, each character in the alphabet needs to be unique.</p> <h2> <a aria-hidden="true" class="anchor" href="#encryption-via-alphabet-rotation" id="user-content-encryption-via-alphabet-rotation"><span aria-hidden="true" class="octicon octicon-link"></span></a>Encryption via Alphabet Rotation</h2> <p>Our encryption strategy will mimic the Romans in preselecting a key and generating a cipher alphabet, then generating cipher characters by matching position:</p> <pre lang="cryptol"><code>encrypt : {n} Key -&gt; String n -&gt; String n encrypt key msg = map rot msg where /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var cipher alphabet github-markdown-css/ html/ labs/ misc/ scripts/ specs/ alphabet' = alphabet &gt;&gt;&gt; key rot c = if (i &lt; length alphabet) then (alphabet' ! i) else c where i = index alphabet c </code></pre> <p>Note the <code>alphabet &gt;&gt;&gt; key</code> part: Cryptol allows rotation not only over bit sequences, ...</p> <pre lang="Xcryptol"><code>labs::Demos::Cryptol::Caesar&gt; :s ascii=off labs::Demos::Cryptol::Caesar&gt; :s base=2 labs::Demos::Cryptol::Caesar&gt; 0b11001010 &lt;&lt;&lt; 4 0b10101100 </code></pre> <p>...but over sequences of arbitrary shape...</p> <pre lang="Xcryptol"><code>labs::Demos::Cryptol::Caesar&gt; :s base=10 labs::Demos::Cryptol::Caesar&gt; [1, 2, 3, 4, 5 : Integer] &lt;&lt;&lt; 3 [4, 5, 1, 2, 3] labs::Demos::Cryptol::Caesar&gt; :s ascii=on labs::Demos::Cryptol::Caesar&gt; "RACECAR " &lt;&lt;&lt; 4 "CAR RACE" labs::Demos::Cryptol::Caesar&gt; :t (&lt;&lt;&lt;) (&lt;&lt;&lt;) : {n, ix, a} (fin n, Integral ix) =&gt; [n]a -&gt; ix -&gt; [n]a </code></pre> <h2> <a aria-hidden="true" class="anchor" href="#decryption" id="user-content-decryption"><span aria-hidden="true" class="octicon octicon-link"></span></a>Decryption</h2> <p>To decrypt, simply swap the plaintext and cipher alphabets in the search and output operations:</p> <pre lang="cryptol"><code>decrypt : {n} Key -&gt; String n -&gt; String n decrypt key msg' = map rot msg' where /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var cipher alphabet github-markdown-css/ html/ labs/ misc/ scripts/ specs/ alphabet' = alphabet &gt;&gt;&gt; key rot c = if (i &lt; length alphabet) then (alphabet ! i) else c where i = index alphabet' c </code></pre> <h2> <a aria-hidden="true" class="anchor" href="#testing" id="user-content-testing"><span aria-hidden="true" class="octicon octicon-link"></span></a>Testing</h2> <p>For a sanity check, we can check some examples...</p> <pre lang="cryptol"><code>/** classic test vector github-markdown-css/ html/ labs/ misc/ scripts/ specs/ property v1 = encrypt 3 "ATTACK AT DAWN" == "XQQXZH XQ AXTK" /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var Wikipedia test vector github-markdown-css/ html/ labs/ misc/ scripts/ specs/ property v2 = encrypt 3 "THE QUICK BROWN FOX JUMPS OVER THE LAZY DOG" == "QEB NRFZH YOLTK CLU GRJMP LSBO QEB IXWV ALD" /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var ROT13 example github-markdown-css/ html/ labs/ misc/ scripts/ specs/ property v3 = encrypt 13 "ABJURER" == "NOWHERE" </code></pre> <p>Though we could <code>:prove</code> these, for static test cases with no variables, it makes more sense to <code>:check</code> these (this saves the solver some work and often speeds up such tests).</p> <pre lang="Xcryptol"><code>labs::Demos::Cryptol::Caesar&gt; :check v1 Using exhaustive testing. Passed 1 tests. Q.E.D. labs::Demos::Cryptol::Caesar&gt; :check v2 Using exhaustive testing. Passed 1 tests. Q.E.D. labs::Demos::Cryptol::Caesar&gt; :check v3 Using exhaustive testing. Passed 1 tests. Q.E.D. </code></pre> <h2> <a aria-hidden="true" class="anchor" href="#properties" id="user-content-properties"><span aria-hidden="true" class="octicon octicon-link"></span></a>Properties</h2> <p>In addition to test vectors, we would like to know whether decryption with the same key recovers the original plaintext for all messages:</p> <pre lang="cryptol"><code>/** Decryption with same key recovers original message github-markdown-css/ html/ labs/ misc/ scripts/ specs/ recovery : {n} fin n =&gt; Key -&gt; String n -&gt; Bit recovery key msg = decrypt key (encrypt key msg) == msg /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var Decrypting encrypted `msg` of length `1` returns original `msg`. github-markdown-css/ html/ labs/ misc/ scripts/ specs/ property recovery_1 = recovery`{1} /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var Decrypting encrypted `msg` of length `2` returns original `msg`. github-markdown-css/ html/ labs/ misc/ scripts/ specs/ property recovery_2 = recovery`{2} /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var Decrypting encrypted `msg` of length `3` returns original `msg`. github-markdown-css/ html/ labs/ misc/ scripts/ specs/ property recovery_3 = recovery`{3} /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var Decrypting encrypted `msg` of length `4` returns original `msg`. github-markdown-css/ html/ labs/ misc/ scripts/ specs/ property recovery_4 = recovery`{4} /Applications /Library /System /Users /Volumes /bin /cores /dev /etc /home /opt /private /sbin /tmp /usr /var Decrypting encrypted `msg` of length `14` returns original `msg`. github-markdown-css/ html/ labs/ misc/ scripts/ specs/ property recovery_14 = recovery`{14} </code></pre> <pre lang="Xcryptol"><code>labs::Demos::Cryptol::Caesar&gt; :prove recovery_4 Q.E.D. (Total Elapsed Time: 0.245s, using "ABC") labs::Demos::Cryptol::Caesar&gt; :prove recovery_14 Q.E.D. (Total Elapsed Time: 0.956s, using "ABC") </code></pre> <h2> <a aria-hidden="true" class="anchor" href="#security-analysis" id="user-content-security-analysis"><span aria-hidden="true" class="octicon octicon-link"></span></a>Security Analysis</h2> <p>So is this a good cipher? Well, no. Let's...here. We can manually deduce a key from known ciphertext...</p> <pre lang="Xcryptol"><code>labs::Demos::Cryptol::Caesar&gt; map (\k -&gt; (k, decrypt k "SXQW SJLXK FJB J SRWPUNQNRVNA BLQVRMC")) [0..25] [(0, "SXQW SJLXK FJB J SRWPUNQNRVNA BLQVRMC"), (1, "TYRX TKMYL GKC K TSXQVOROSWOB CMRWSND"), (2, "UZSY ULNZM HLD L UTYRWPSPTXPC DNSXTOE"), (3, "VATZ VMOAN IME M VUZSXQTQUYQD EOTYUPF"), (4, "WBUA WNPBO JNF N WVATYRURVZRE FPUZVQG"), (5, "XCVB XOQCP KOG O XWBUZSVSWASF GQVAWRH"), (6, "YDWC YPRDQ LPH P YXCVATWTXBTG HRWBXSI"), (7, "ZEXD ZQSER MQI Q ZYDWBUXUYCUH ISXCYTJ"), (8, "AFYE ARTFS NRJ R AZEXCVYVZDVI JTYDZUK"), (9, "BGZF BSUGT OSK S BAFYDWZWAEWJ KUZEAVL"), (10, "CHAG CTVHU PTL T CBGZEXAXBFXK LVAFBWM"), (11, "DIBH DUWIV QUM U DCHAFYBYCGYL MWBGCXN"), (12, "EJCI EVXJW RVN V EDIBGZCZDHZM NXCHDYO"), (13, "FKDJ FWYKX SWO W FEJCHADAEIAN OYDIEZP"), (14, "GLEK GXZLY TXP X GFKDIBEBFJBO PZEJFAQ"), (15, "HMFL HYAMZ UYQ Y HGLEJCFCGKCP QAFKGBR"), (16, "INGM IZBNA VZR Z IHMFKDGDHLDQ RBGLHCS"), (17, "JOHN JACOB WAS A JINGLEHEIMER SCHMIDT"), (18, "KPIO KBDPC XBT B KJOHMFIFJNFS TDINJEU"), (19, "LQJP LCEQD YCU C LKPINGJGKOGT UEJOKFV"), (20, "MRKQ MDFRE ZDV D MLQJOHKHLPHU VFKPLGW"), (21, "NSLR NEGSF AEW E NMRKPILIMQIV WGLQMHX"), (22, "OTMS OFHTG BFX F ONSLQJMJNRJW XHMRNIY"), (23, "PUNT PGIUH CGY G POTMRKNKOSKX YINSOJZ"), (24, "QVOU QHJVI DHZ H QPUNSLOLPTLY ZJOTPKA"), (25, "RWPV RIKWJ EIA I RQVOTMPMQUMZ AKPUQLB")] </code></pre> <p>...and we can recover a key from chosen plaintext through SAT solving...here we switch solvers back to <code>z3</code> because <code>abc</code> sometimes has troubles with this one.</p> <pre lang="Xcryptol"><code>labs::Demos::Cryptol::Caesar&gt; :s prover=z3 labs::Demos::Cryptol::Caesar&gt; :sat \k -&gt; encrypt k "ILLUMINATI CONFIRMED" == "NQQZRNSFYN HTSKNWRJI" Satisfiable (\k -&gt; encrypt k "ILLUMINATI CONFIRMED" == "NQQZRNSFYN HTSKNWRJI") 21 = True (Total Elapsed Time: 0.089s, using "ABC") </code></pre> <h1> <a aria-hidden="true" class="anchor" href="#conclusion" id="user-content-conclusion"><span aria-hidden="true" class="octicon octicon-link"></span></a>Conclusion</h1> <p>You came, you saw, and you conquered the Caesar cipher in Cryptol. Ave, Caesar!</p> <h1> <a aria-hidden="true" class="anchor" href="#solicitation" id="user-content-solicitation"><span aria-hidden="true" class="octicon octicon-link"></span></a>Solicitation</h1> <p>How was your experience with this labs Suggestions are welcome in the form of a ticket on the course GitHub page: <a href="https://github.com/weaversa/cryptol-course/issues">https://github.com/weaversa/cryptol-course/issues</a></p> <h1> <a aria-hidden="true" class="anchor" href="#from-here-you-can-go-somewhere" id="user-content-from-here-you-can-go-somewhere"><span aria-hidden="true" class="octicon octicon-link"></span></a>From here, you can go somewhere!</h1> <table> <thead> <tr> <th align="right"></th> <th align="center"></th> <th></th> </tr> </thead> <tbody> <tr> <td align="right"></td> <td align="center"><a href="/labs/Demos/Cryptol/Demos.html">^ Cryptol Demos</a></td> <td></td> </tr> <tr> <td align="right"></td> <td align="center"><strong>Caesar</strong></td> <td><a href="/labs/Demos/Cryptol/OneTimePad.html">One-Time Pad &gt;</a></td> </tr> </tbody> </table> </article> </div> </div> </div> </div> </div> </div>
